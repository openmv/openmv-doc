<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>image — machine vision &mdash; MicroPython 1.19 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/customstyle.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/openmv.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="tf — Tensor Flow" href="omv.tf.html" />
    <link rel="prev" title="sensor — camera sensor" href="omv.sensor.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MicroPython
              <img src="../_static/web-logo-sticky.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.19
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">MicroPython libraries</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#python-standard-libraries-and-micro-libraries">Python standard libraries and micro-libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#micropython-specific-libraries">MicroPython-specific libraries</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#libraries-specific-to-the-openmv-cam">Libraries specific to the OpenMV Cam</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="pyb.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyb</span></code> — functions related to the board</a></li>
<li class="toctree-l3"><a class="reference internal" href="stm.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stm</span></code> — functionality specific to STM32 MCUs</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.sensor.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sensor</span></code> — camera sensor</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">image</span></code> — machine vision</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-haarcascade-feature-descriptor">class HaarCascade – Feature Descriptor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-histogram-histogram-object">class Histogram – Histogram Object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-percentile-percentile-object">class Percentile – Percentile Object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-threshold-threshold-object">class Threshold – Threshold Object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-statistics-statistics-object">class Statistics – Statistics Object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-blob-blob-object">class Blob – Blob object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-line-line-object">class Line – Line object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-circle-circle-object">class Circle – Circle object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-rect-rectangle-object">class Rect – Rectangle Object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-qrcode-qrcode-object">class QRCode – QRCode object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-apriltag-apriltag-object">class AprilTag – AprilTag object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-datamatrix-datamatrix-object">class DataMatrix – DataMatrix object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-barcode-barcode-object">class BarCode – BarCode object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-displacement-displacement-object">class Displacement – Displacement object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-kptmatch-keypoint-object">class kptmatch – Keypoint Object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-imageio-imageio-object">class ImageIO  – ImageIO Object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#class-image-image-object">class Image – Image object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#constants">Constants</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="omv.tf.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tf</span></code> — Tensor Flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.gif.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gif</span></code> — gif recording</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.mjpeg.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mjpeg</span></code> — mjpeg recording</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.audio.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audio</span></code> — Audio Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.micro_speech.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">micro_speech</span></code> — Micro Speech Audio Module Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.lcd.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lcd</span></code> — lcd driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.fir.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fir</span></code> — thermal sensor driver (fir == far infrared)</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.tv.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tv</span></code> — tv shield driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.cpufreq.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cpufreq</span></code> — CPU Frequency Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.buzzer.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">buzzer</span></code> — buzzer driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.imu.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">imu</span></code> — imu sensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.rpc.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rpc</span></code> — rpc library</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.rtsp.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rtsp</span></code> — rtsp library</a></li>
<li class="toctree-l3"><a class="reference internal" href="omv.omv.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">omv</span></code> — OpenMV Cam Information</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#third-party-libraries-on-the-openmv-cam">Third-party libraries on the OpenMV Cam</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#extending-built-in-libraries-from-python">Extending built-in libraries from Python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">MicroPython language and implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genrst/index.html">MicroPython differences from CPython</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">MicroPython license information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openmvcam/quickref.html">Quick reference for the openmvcam</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MicroPython</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">MicroPython libraries</a></li>
      <li class="breadcrumb-item active"><code class="xref py py-mod docutils literal notranslate"><span class="pre">image</span></code> — machine vision</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/library/omv.image.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-image">
<span id="image-machine-vision"></span><h1><a class="reference internal" href="#module-image" title="image: machine vision"><code class="xref py py-mod docutils literal notranslate"><span class="pre">image</span></code></a> — machine vision<a class="headerlink" href="#module-image" title="Permalink to this heading">¶</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">image</span></code> module is used for machine vision.</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="image.binary_to_grayscale">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">binary_to_grayscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_image_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.binary_to_grayscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted binary value (0-1) to a grayscale value (0-255).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.binary_to_rgb">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">binary_to_rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_image_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.binary_to_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted binary value (0-1) to a 3 value RGB888 tuple.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.binary_to_lab">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">binary_to_lab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_image_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.binary_to_lab" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted binary value (0-1) to a 3 value LAB tuple.</p>
<p>L goes between 0 and 100 and A/B go from -128 to 128.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.binary_to_yuv">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">binary_to_yuv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">binary_image_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.binary_to_yuv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted binary value (0-1) to a 3 value YUV tuple.</p>
<p>Y goes between 0 and 255 and U/V go from -128 to 128.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.grayscale_to_binary">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">grayscale_to_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grayscale_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.grayscale_to_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted grayscale value (0-255) to a binary value (0-1).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.grayscale_to_rgb">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">grayscale_to_rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grayscale_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.grayscale_to_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted grayscale value to a 3 value RGB888 tuple.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a RGB565-&gt;RGB888 process
so this method won’t return the exact values as a pure RGB888 system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.grayscale_to_lab">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">grayscale_to_lab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grayscale_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.grayscale_to_lab" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted grayscale value to a 3 value LAB tuple.</p>
<p>L goes between 0 and 100 and A/B go from -128 to 128.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a RGB565-&gt;LAB process
so this method won’t return the exact values as a pure LAB system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.grayscale_to_yuv">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">grayscale_to_yuv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grayscale_value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.grayscale_to_yuv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted grayscale value to a 3 value YUV tuple.</p>
<p>Y goes between 0 and 255 and U/V go from -128 to 128.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a RGB565-&gt;YUV process
so this method won’t return the exact values as a pure YUV system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.rgb_to_binary">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">rgb_to_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.rgb_to_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value RGB888 tuple to a center range thresholded binary value (0-1).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a RGB888-&gt;RGB565 process
so this method won’t return the exact values as a pure RGB888 system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.rgb_to_grayscale">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">rgb_to_grayscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.rgb_to_grayscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value RGB888 tuple to a grayscale value (0-255).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a RGB888-&gt;RGB565 process
so this method won’t return the exact values as a pure RGB888 system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.rgb_to_lab">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">rgb_to_lab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.rgb_to_lab" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value RGB888 tuple to a 3 value LAB tuple.</p>
<p>L goes between 0 and 100 and A/B go from -128 to 128.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a RGB888-&gt;RGB565 process
so this method won’t return the exact values as a pure RGB888 system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.rgb_to_yuv">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">rgb_to_yuv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.rgb_to_yuv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value RGB888 tuple to a 3 value YUV tuple.</p>
<p>Y goes between 0 and 255 and U/V go from -128 to 128.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a RGB888-&gt;RGB565 process
so this method won’t return the exact values as a pure RGB888 system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.lab_to_binary">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">lab_to_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.lab_to_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value LAB tuple to a center range thresholded binary value (0-1).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a LAB-&gt;RGB565 process
so this method won’t return the exact values as a pure LAB system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.lab_to_grayscale">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">lab_to_grayscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.lab_to_grayscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value LAB tuple to a grayscale value (0-255).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a LAB-&gt;RGB565 process
so this method won’t return the exact values as a pure LAB system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.lab_to_rgb">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">lab_to_rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.lab_to_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value LAB tuple to a 3 value RGB888 tuple.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a LAB-&gt;RGB565 process
so this method won’t return the exact values as a pure LAB system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.lab_to_yuv">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">lab_to_yuv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.lab_to_yuv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value LAB tuple to a 3 value YUV tuple.</p>
<p>Y goes between 0 and 255 and U/V go from -128 to 128.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a LAB-&gt;RGB565 process
so this method won’t return the exact values as a pure LAB system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.yuv_to_binary">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">yuv_to_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yuv_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.yuv_to_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value YUV tuple to a center range thresholded binary value (0-1).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a YUV-&gt;RGB565 process
so this method won’t return the exact values as a pure YUV system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.yuv_to_grayscale">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">yuv_to_grayscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yuv_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.yuv_to_grayscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value YUV tuple to a grayscale value (0-255).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a YUV-&gt;RGB565 process
so this method won’t return the exact values as a pure YUV system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.yuv_to_rgb">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">yuv_to_rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.yuv_to_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value YUV tuple to a 3 value RGB888 tuple.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a YUV-&gt;RGB565 process
so this method won’t return the exact values as a pure YUV system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.yuv_to_lab">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">yuv_to_lab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yuv_tuple</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.yuv_to_lab" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a converted 3 value YUV tuple to a 3 value LAB tuple.</p>
<p>L goes between 0 and 100 and A/B go from -128 to 128.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenMV Cam firmware does the conversion using a YUV-&gt;RGB565 process
so this method won’t return the exact values as a pure YUV system would.
However, it’s true to how the image lib works internally.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.load_decriptor">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">load_decriptor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.load_decriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a descriptor object from disk.</p>
<p><code class="docutils literal notranslate"><span class="pre">path</span></code> is the path to the descriptor file to load.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.save_descriptor">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">save_descriptor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descriptor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.save_descriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the descriptor object <code class="docutils literal notranslate"><span class="pre">descriptor</span></code> to disk.</p>
<p><code class="docutils literal notranslate"><span class="pre">path</span></code> is the path to the descriptor file to save.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="image.match_descriptor">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">match_descriptor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descritor0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descriptor1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=70</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">filter_outliers=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.match_descriptor" title="Permalink to this definition">¶</a></dt>
<dd><p>For LBP descriptors this function returns an integer representing the
difference between the two descriptors. You may then threshold/compare this
distance metric as necessary. The distance is a measure of similarity. The
closer it is to zero the better the LBP keypoint match.</p>
<p>For ORB descriptors this function returns the <code class="docutils literal notranslate"><span class="pre">kptmatch</span></code> object. See above.</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> is used for ORB keypoints to filter ambiguous matches. A lower
<code class="docutils literal notranslate"><span class="pre">threshold</span></code> value tightens the keypoint matching algorithm. <code class="docutils literal notranslate"><span class="pre">threshold</span></code>
may be between 0-100 (int). Defaults to 70.</p>
<p><code class="docutils literal notranslate"><span class="pre">filter_outliers</span></code> is used for ORB keypoints to filter out outlier
keypoints allow you to raise the <code class="docutils literal notranslate"><span class="pre">threshold</span></code>. Defaults to False.</p>
</dd></dl>

</section>
<section id="class-haarcascade-feature-descriptor">
<h2>class HaarCascade – Feature Descriptor<a class="headerlink" href="#class-haarcascade-feature-descriptor" title="Permalink to this heading">¶</a></h2>
<p>The Haar Cascade feature descriptor is used for the <a class="reference internal" href="#image.Image.find_features" title="image.Image.find_features"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_features()</span></code></a>
method. It doesn’t have any methods itself for you to call.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.HaarCascade">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">HaarCascade</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">stages=Auto</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.HaarCascade" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a Haar Cascade into memory from a Haar Cascade binary file formatted
for your OpenMV Cam. If you pass “frontalface” instead of a path then this
constructor will load the built-in frontal face Haar Cascade into memory.
Additionally, you can also pass “eye” to load a Haar Cascade for eyes into
memory. Finally, this method returns the loaded Haar Cascade object for use
with <a class="reference internal" href="#image.Image.find_features" title="image.Image.find_features"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_features()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">stages</span></code> defaults to the number of stages in the Haar Cascade. However,
you can specify a lower number of stages to speed up processing the feature
detector at the cost of a higher rate of false positives.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can make your own Haar Cascades to use with your OpenMV Cam.
First, Google for “&lt;thing&gt; Haar Cascade” to see if someone
already made an OpenCV Haar Cascade for an object you want to
detect. If not… then you’ll have to generate your own (which is
a lot of work). See <a class="reference external" href="http://coding-robin.de/2013/07/22/train-your-own-opencv-haar-classifier.html">here</a>
for how to make your own Haar Cascade. Then see this <a class="reference external" href="https://github.com/openmv/openmv/blob/master/usr/openmv-cascade.py">script</a>
for converting OpenCV Haar Cascades into a format your OpenMV Cam
can read.</p>
</div>
<p>Q: What is a Haar Cascade?</p>
<p>A: A Haar Cascade is a series of contrast checks that are used to determine
if an object is present in the image. The contrast checks are split of into
stages where a stage is only run if previous stages have already passed.
The contrast checks are simple things like checking if the center vertical
of the image is lighter than the edges. Large area checks are performed
first in the earlier stages followed by more numerous and smaller area
checks in later stages.</p>
<p>Q: How are Haar Cascades made?</p>
<p>A: Haar Cascades are made by training the generator algorithm against
positive and negative labeled images. For example, you’d train the
generator algorithm against hundreds of pictures with cats in them that
have been labeled as images with cats and against hundreds of images with
not cat like things labeled differently. The generator algorithm will then
produce a Haar Cascade that detects cats.</p>
</dd></dl>

</section>
<section id="class-histogram-histogram-object">
<h2>class Histogram – Histogram Object<a class="headerlink" href="#class-histogram-histogram-object" title="Permalink to this heading">¶</a></h2>
<p>The histogram object is returned by <a class="reference internal" href="#image.Image.get_histogram" title="image.Image.get_histogram"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.get_histogram()</span></code></a>.</p>
<p>Grayscale histograms have one channel with some number of bins. All bins are
normalized so that all bins sum to 1.</p>
<p>RGB565 histograms have three channels with some number of bins each. All bins
are normalized so that all bins in a channel sum to 1.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.histogram">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">histogram</span></span><a class="headerlink" href="#image.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.Image.get_histogram" title="image.Image.get_histogram"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.get_histogram()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.histogram.bins">
<span class="sig-name descname"><span class="pre">bins</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.histogram.bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of floats for the grayscale histogram.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.histogram.l_bins">
<span class="sig-name descname"><span class="pre">l_bins</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.histogram.l_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of floats for the RGB565 histogram LAB L channel.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.histogram.a_bins">
<span class="sig-name descname"><span class="pre">a_bins</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.histogram.a_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of floats for the RGB565 histogram LAB A channel.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.histogram.b_bins">
<span class="sig-name descname"><span class="pre">b_bins</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.histogram.b_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of floats for the RGB565 histogram LAB B channel.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.histogram.get_percentile">
<span class="sig-name descname"><span class="pre">get_percentile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">percentile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.histogram.get_percentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the CDF of the histogram channels and returns a <a class="reference internal" href="#image.percentile" title="image.percentile"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.percentile</span></code></a>
object with the values of the histogram at the passed in <code class="docutils literal notranslate"><span class="pre">percentile</span></code> (0.0
- 1.0) (float). So, if you pass in 0.1 this method will tell you (going from
left-to-right in the histogram) what bin when summed into an accumulator
caused the accumulator to cross 0.1. This is useful to determine min (with
0.1) and max (with 0.9) of a color distribution without outlier effects
ruining your results for adaptive color tracking.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.histogram.get_threshold">
<span class="sig-name descname"><span class="pre">get_threshold</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.histogram.get_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses Otsu’s Method to compute the optimal threshold values that split the
histogram into two halves for each channel of the histogram. This method
returns a <a class="reference internal" href="#image.threshold" title="image.threshold"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.threshold</span></code></a> object. This method is particularly useful for
determining optimal <a class="reference internal" href="#image.Image.binary" title="image.Image.binary"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.binary()</span></code></a> thresholds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.histogram.get_statistics">
<span class="sig-name descname"><span class="pre">get_statistics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.histogram.get_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the mean, median, mode, standard deviation, min, max, lower
quartile, and upper quartile of each color channel in the histogram and
returns a <a class="reference internal" href="#image.statistics" title="image.statistics"><code class="xref any py py-class docutils literal notranslate"><span class="pre">statistics</span></code></a> object.</p>
<p>You may also use <code class="docutils literal notranslate"><span class="pre">histogram.statistics()</span></code> and <code class="docutils literal notranslate"><span class="pre">histogram.get_stats()</span></code>
as aliases for this method.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-percentile-percentile-object">
<h2>class Percentile – Percentile Object<a class="headerlink" href="#class-percentile-percentile-object" title="Permalink to this heading">¶</a></h2>
<p>The percentile object is returned by <a class="reference internal" href="#image.histogram.get_percentile" title="image.histogram.get_percentile"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">histogram.get_percentile()</span></code></a>.</p>
<p>Grayscale percentiles have one channel. Use the non <code class="docutils literal notranslate"><span class="pre">l_*</span></code>, <code class="docutils literal notranslate"><span class="pre">a_*</span></code>, and
<code class="docutils literal notranslate"><span class="pre">b_*</span></code> method.</p>
<p>RGB565 percentiles have three channels. Use the <code class="docutils literal notranslate"><span class="pre">l_*</span></code>, <code class="docutils literal notranslate"><span class="pre">a_*</span></code>, and <code class="docutils literal notranslate"><span class="pre">b_*</span></code>
methods.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.percentile">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">percentile</span></span><a class="headerlink" href="#image.percentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.histogram.get_percentile" title="image.histogram.get_percentile"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">histogram.get_percentile()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.percentile.value">
<span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.percentile.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the grayscale percentile value (between 0 and 255).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.percentile.l_value">
<span class="sig-name descname"><span class="pre">l_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.percentile.l_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RGB565 LAB L channel percentile value (between 0 and 100).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.percentile.a_value">
<span class="sig-name descname"><span class="pre">a_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.percentile.a_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RGB565 LAB A channel percentile value (between -128 and 127).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.percentile.b_value">
<span class="sig-name descname"><span class="pre">b_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.percentile.b_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RGB565 LAB B channel percentile value (between -128 and 127).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-threshold-threshold-object">
<h2>class Threshold – Threshold Object<a class="headerlink" href="#class-threshold-threshold-object" title="Permalink to this heading">¶</a></h2>
<p>The threshold object is returned by <a class="reference internal" href="#image.histogram.get_threshold" title="image.histogram.get_threshold"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">histogram.get_threshold()</span></code></a>.</p>
<p>Grayscale thresholds have one channel. Use the non <code class="docutils literal notranslate"><span class="pre">l_*</span></code>, <code class="docutils literal notranslate"><span class="pre">a_*</span></code>, and
<code class="docutils literal notranslate"><span class="pre">b_*</span></code> method.</p>
<p>RGB565 thresholds have three channels. Use the <code class="docutils literal notranslate"><span class="pre">l_*</span></code>, <code class="docutils literal notranslate"><span class="pre">a_*</span></code>, and <code class="docutils literal notranslate"><span class="pre">b_*</span></code>
methods.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.threshold">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">threshold</span></span><a class="headerlink" href="#image.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.histogram.get_threshold" title="image.histogram.get_threshold"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">histogram.get_threshold()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.threshold.value">
<span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.threshold.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the grayscale threshold value (between 0 and 255).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.threshold.l_value">
<span class="sig-name descname"><span class="pre">l_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.threshold.l_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RGB565 LAB L channel threshold value (between 0 and 100).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.threshold.a_value">
<span class="sig-name descname"><span class="pre">a_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.threshold.a_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RGB565 LAB A channel threshold value (between -128 and 127).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.threshold.b_value">
<span class="sig-name descname"><span class="pre">b_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.threshold.b_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RGB565 LAB B channel threshold value (between -128 and 127).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-statistics-statistics-object">
<h2>class Statistics – Statistics Object<a class="headerlink" href="#class-statistics-statistics-object" title="Permalink to this heading">¶</a></h2>
<p>The percentile object is returned by <a class="reference internal" href="#image.histogram.get_statistics" title="image.histogram.get_statistics"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">histogram.get_statistics()</span></code></a> or
<a class="reference internal" href="#image.Image.get_statistics" title="image.Image.get_statistics"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.get_statistics()</span></code></a>.</p>
<p>Grayscale statistics have one channel. Use the non <code class="docutils literal notranslate"><span class="pre">l_*</span></code>, <code class="docutils literal notranslate"><span class="pre">a_*</span></code>, and
<code class="docutils literal notranslate"><span class="pre">b_*</span></code> method.</p>
<p>RGB565 statistics have three channels. Use the <code class="docutils literal notranslate"><span class="pre">l_*</span></code>, <code class="docutils literal notranslate"><span class="pre">a_*</span></code>, and <code class="docutils literal notranslate"><span class="pre">b_*</span></code>
methods.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.statistics">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">statistics</span></span><a class="headerlink" href="#image.statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.histogram.get_statistics" title="image.histogram.get_statistics"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">histogram.get_statistics()</span></code></a> or <a class="reference internal" href="#image.Image.get_statistics" title="image.Image.get_statistics"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.get_statistics()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.mean">
<span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the grayscale mean (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.median">
<span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the grayscale median (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.mode">
<span class="sig-name descname"><span class="pre">mode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the grayscale mode (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.stdev">
<span class="sig-name descname"><span class="pre">stdev</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the grayscale standard deviation (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the grayscale min (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the grayscale max (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[5]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.lq">
<span class="sig-name descname"><span class="pre">lq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.lq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the grayscale lower quartile (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[6]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.uq">
<span class="sig-name descname"><span class="pre">uq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.uq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the grayscale upper quartile (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[7]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.l_mean">
<span class="sig-name descname"><span class="pre">l_mean</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.l_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB L mean (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.l_median">
<span class="sig-name descname"><span class="pre">l_median</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.l_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB L median (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.l_mode">
<span class="sig-name descname"><span class="pre">l_mode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.l_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB L mode (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.l_stdev">
<span class="sig-name descname"><span class="pre">l_stdev</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.l_stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB L standard deviation (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.l_min">
<span class="sig-name descname"><span class="pre">l_min</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.l_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB L min (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.l_max">
<span class="sig-name descname"><span class="pre">l_max</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.l_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB L max (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[5]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.l_lq">
<span class="sig-name descname"><span class="pre">l_lq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.l_lq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB L lower quartile (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[6]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.l_uq">
<span class="sig-name descname"><span class="pre">l_uq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.l_uq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB L upper quartile (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[7]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.a_mean">
<span class="sig-name descname"><span class="pre">a_mean</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.a_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB A mean (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[8]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.a_median">
<span class="sig-name descname"><span class="pre">a_median</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.a_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB A median (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[9]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.a_mode">
<span class="sig-name descname"><span class="pre">a_mode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.a_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB A mode (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[10]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.a_stdev">
<span class="sig-name descname"><span class="pre">a_stdev</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.a_stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB A standard deviation (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[11]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.a_min">
<span class="sig-name descname"><span class="pre">a_min</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.a_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB A min (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[12]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.a_max">
<span class="sig-name descname"><span class="pre">a_max</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.a_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB A max (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[13]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.a_lq">
<span class="sig-name descname"><span class="pre">a_lq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.a_lq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB A lower quartile (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[14]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.a_uq">
<span class="sig-name descname"><span class="pre">a_uq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.a_uq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB A upper quartile (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[15]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.b_mean">
<span class="sig-name descname"><span class="pre">b_mean</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.b_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB B mean (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[16]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.b_median">
<span class="sig-name descname"><span class="pre">b_median</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.b_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB B median (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[17]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.b_mode">
<span class="sig-name descname"><span class="pre">b_mode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.b_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB B mode (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[18]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.b_stdev">
<span class="sig-name descname"><span class="pre">b_stdev</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.b_stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB B standard deviation (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[19]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.b_min">
<span class="sig-name descname"><span class="pre">b_min</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.b_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB B min (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[20]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.b_max">
<span class="sig-name descname"><span class="pre">b_max</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.b_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB B max (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[21]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.b_lq">
<span class="sig-name descname"><span class="pre">b_lq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.b_lq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB B lower quartile (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[22]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.statistics.b_uq">
<span class="sig-name descname"><span class="pre">b_uq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.statistics.b_uq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RGB565 LAB B upper quartile (0-255) (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[23]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-blob-blob-object">
<h2>class Blob – Blob object<a class="headerlink" href="#class-blob-blob-object" title="Permalink to this heading">¶</a></h2>
<p>The blob object is returned by <a class="reference internal" href="#image.Image.find_blobs" title="image.Image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_blobs()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.blob">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">blob</span></span><a class="headerlink" href="#image.blob" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.Image.find_blobs" title="image.Image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_blobs()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.blob.corners">
<span class="sig-name descname"><span class="pre">corners</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 4 (x,y) tuples of the 4 corners of the object. Corners are
always returned in sorted clock-wise order starting from the top left.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.min_corners">
<span class="sig-name descname"><span class="pre">min_corners</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.min_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 4 (x,y) tuples of the 4 corners than bound the min area
rectangle of the blob. Unlike <a class="reference internal" href="#image.blob.corners" title="image.blob.corners"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.corners()</span></code></a> the min area rectangle corners
do not necessarily lie on the blob.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.rect">
<span class="sig-name descname"><span class="pre">rect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rectangle tuple (x, y, w, h) for use with other <a class="reference internal" href="#module-image" title="image: machine vision"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">image</span></code></a> methods
like <a class="reference internal" href="#image.Image.draw_rectangle" title="image.Image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_rectangle()</span></code></a> of the blob’s bounding box.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the blob’s bounding box x coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the blob’s bounding box y coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.w">
<span class="sig-name descname"><span class="pre">w</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.w" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the blob’s bounding box w coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.h">
<span class="sig-name descname"><span class="pre">h</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.h" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the blob’s bounding box h coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.pixels">
<span class="sig-name descname"><span class="pre">pixels</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of pixels that are part of this blob (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.cx">
<span class="sig-name descname"><span class="pre">cx</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.cx" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid x position of the blob (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[5]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.cxf">
<span class="sig-name descname"><span class="pre">cxf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.cxf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid x position of the blob (float).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.cy">
<span class="sig-name descname"><span class="pre">cy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.cy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid y position of the blob (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[6]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.cyf">
<span class="sig-name descname"><span class="pre">cyf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.cyf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid y position of the blob (float).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.rotation">
<span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation of the blob in radians (float). If the blob is like
a pencil or pen this value will be unique for 0-180 degrees. If the blob
is round this value is not useful.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[7]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.rotation_deg">
<span class="sig-name descname"><span class="pre">rotation_deg</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.rotation_deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation of the blob in degrees.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.rotation_rad">
<span class="sig-name descname"><span class="pre">rotation_rad</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.rotation_rad" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation of the blob in radians. This method is more descriptive
than just <a class="reference internal" href="#image.blob.rotation" title="image.blob.rotation"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.rotation()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.code">
<span class="sig-name descname"><span class="pre">code</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.code" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 32-bit binary number with a bit set in it for each color threshold
that’s part of this blob. For example, if you passed <a class="reference internal" href="#image.Image.find_blobs" title="image.Image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_blobs()</span></code></a>
three color thresholds to look for then bits 0/1/2 may be set for this blob.
Note that only one bit will be set for each blob unless <a class="reference internal" href="#image.Image.find_blobs" title="image.Image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_blobs()</span></code></a>
was called with <code class="docutils literal notranslate"><span class="pre">merge=True</span></code>. Then its possible for multiple blobs with
different color thresholds to be merged together. You can use this method
along with multiple thresholds to implement color code tracking.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[8]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of blobs merged into this blob. This is 1 unless you
called <a class="reference internal" href="#image.Image.find_blobs" title="image.Image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_blobs()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">merge=True</span></code>.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[9]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.perimeter">
<span class="sig-name descname"><span class="pre">perimeter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.perimeter" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of pixels on this blob’s perimeter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.roundness">
<span class="sig-name descname"><span class="pre">roundness</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.roundness" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a value between 0 and 1 representing how round the object is. A circle would be a 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.elongation">
<span class="sig-name descname"><span class="pre">elongation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.elongation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a value between 0 and 1 representing how long (not round) the object is. A line would be a 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.area">
<span class="sig-name descname"><span class="pre">area</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.area" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the area of the bounding box around the blob. (w * h).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.density">
<span class="sig-name descname"><span class="pre">density</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.density" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the density ratio of the blob. This is the number of pixels in the
blob over its bounding box area. A low density ratio means in general that
the lock on the object isn’t very good. The result is between 0 and 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.extent">
<span class="sig-name descname"><span class="pre">extent</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.extent" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <a class="reference internal" href="#image.blob.density" title="image.blob.density"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.density()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.compactness">
<span class="sig-name descname"><span class="pre">compactness</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.compactness" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#image.blob.density" title="image.blob.density"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.density()</span></code></a>, but, uses the perimeter of the blob instead to measure
the objects density and is thus more accurate. The result is between 0 and 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.solidity">
<span class="sig-name descname"><span class="pre">solidity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.solidity" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#image.blob.density" title="image.blob.density"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.density()</span></code></a> but, uses the minimum area rotated rectangle versus the
bounding rectangle to measure density. The result is between 0 and 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.convexity">
<span class="sig-name descname"><span class="pre">convexity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.convexity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a value between 0 and 1 representing how convex the object is. A square would be 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.x_hist_bins">
<span class="sig-name descname"><span class="pre">x_hist_bins</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.x_hist_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a histogram of the x axis of all columns in a blob. Bin values are
scaled between 0 and 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.y_hist_bins">
<span class="sig-name descname"><span class="pre">y_hist_bins</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.y_hist_bins" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a histogram of the y axis of all the rows in a blob. Bin values are
scaled between 0 and 1.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.major_axis_line">
<span class="sig-name descname"><span class="pre">major_axis_line</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.major_axis_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a line tuple (x1, y1, x2, y2) that can be drawn with <a class="reference internal" href="#image.Image.draw_line" title="image.Image.draw_line"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_line()</span></code></a> of the major
axis of the blob (the line going through the longest side of the min area rectangle).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.minor_axis_line">
<span class="sig-name descname"><span class="pre">minor_axis_line</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.minor_axis_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a line tuple (x1, y1, x2, y2) that can be drawn with <a class="reference internal" href="#image.Image.draw_line" title="image.Image.draw_line"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_line()</span></code></a> of the minor
axis of the blob (the line going through the shortest side of the min area rectangle).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.enclosing_circle">
<span class="sig-name descname"><span class="pre">enclosing_circle</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.enclosing_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a circle tuple (x, y, r) that can be drawn with <a class="reference internal" href="#image.Image.draw_circle" title="image.Image.draw_circle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_circle()</span></code></a> of
the circle that encloses the min area rectangle of a blob.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.blob.enclosed_ellipse">
<span class="sig-name descname"><span class="pre">enclosed_ellipse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.blob.enclosed_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an ellipse tuple (x, y, rx, ry, rotation) that can be drawn with <a class="reference internal" href="#image.Image.draw_ellipse" title="image.Image.draw_ellipse"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_ellipse()</span></code></a>
of the ellipse that fits inside of the min area rectangle of a blob.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-line-line-object">
<h2>class Line – Line object<a class="headerlink" href="#class-line-line-object" title="Permalink to this heading">¶</a></h2>
<p>The line object is returned by <a class="reference internal" href="#image.Image.find_lines" title="image.Image.find_lines"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_lines()</span></code></a>, <a class="reference internal" href="#image.Image.find_line_segments" title="image.Image.find_line_segments"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_line_segments()</span></code></a>, or <a class="reference internal" href="#image.Image.get_regression" title="image.Image.get_regression"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.get_regression()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.line">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">line</span></span><a class="headerlink" href="#image.line" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.Image.find_lines" title="image.Image.find_lines"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_lines()</span></code></a>, <a class="reference internal" href="#image.Image.find_line_segments" title="image.Image.find_line_segments"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_line_segments()</span></code></a>, or <a class="reference internal" href="#image.Image.get_regression" title="image.Image.get_regression"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.get_regression()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.line.line">
<span class="sig-name descname"><span class="pre">line</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.line.line" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a line tuple (x1, y1, x2, y2) for use with other <a class="reference internal" href="#module-image" title="image: machine vision"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">image</span></code></a> methods
like <a class="reference internal" href="#image.Image.draw_line" title="image.Image.draw_line"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_line()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.line.x1">
<span class="sig-name descname"><span class="pre">x1</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.line.x1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the line’s p1 x component.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.line.y1">
<span class="sig-name descname"><span class="pre">y1</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.line.y1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the line’s p1 y component.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.line.x2">
<span class="sig-name descname"><span class="pre">x2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.line.x2" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the line’s p2 x component.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.line.y2">
<span class="sig-name descname"><span class="pre">y2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.line.y2" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the line’s p2 y component.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.line.length">
<span class="sig-name descname"><span class="pre">length</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.line.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the line’s length: sqrt(((x2-x1)^2) + ((y2-y1)^2).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.line.magnitude">
<span class="sig-name descname"><span class="pre">magnitude</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.line.magnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the magnitude of the line from the hough transform.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[5]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.line.theta">
<span class="sig-name descname"><span class="pre">theta</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.line.theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angle of the line from the hough transform - (0 - 179) degrees.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[7]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.line.rho">
<span class="sig-name descname"><span class="pre">rho</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.line.rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the the rho value for the line from the hough transform.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[8]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-circle-circle-object">
<h2>class Circle – Circle object<a class="headerlink" href="#class-circle-circle-object" title="Permalink to this heading">¶</a></h2>
<p>The circle object is returned by <a class="reference internal" href="#image.Image.find_circles" title="image.Image.find_circles"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_circles()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.circle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">circle</span></span><a class="headerlink" href="#image.circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.Image.find_circles" title="image.Image.find_circles"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_circles()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.circle.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.circle.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the circle’s x position.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.circle.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.circle.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the circle’s y position.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.circle.r">
<span class="sig-name descname"><span class="pre">r</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.circle.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the circle’s radius.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.circle.magnitude">
<span class="sig-name descname"><span class="pre">magnitude</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.circle.magnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the circle’s magnitude.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-rect-rectangle-object">
<h2>class Rect – Rectangle Object<a class="headerlink" href="#class-rect-rectangle-object" title="Permalink to this heading">¶</a></h2>
<p>The rect object is returned by <a class="reference internal" href="#image.Image.find_rects" title="image.Image.find_rects"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_rects()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.rect">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">rect</span></span><a class="headerlink" href="#image.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.Image.find_rects" title="image.Image.find_rects"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_rects()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.rect.corners">
<span class="sig-name descname"><span class="pre">corners</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.rect.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 4 (x,y) tuples of the 4 corners of the object. Corners are
always returned in sorted clock-wise order starting from the top left.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.rect.rect">
<span class="sig-name descname"><span class="pre">rect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.rect.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rectangle tuple (x, y, w, h) for use with other <a class="reference internal" href="#module-image" title="image: machine vision"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">image</span></code></a> methods
like <a class="reference internal" href="#image.Image.draw_rectangle" title="image.Image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_rectangle()</span></code></a> of the rect’s bounding box.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.rect.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.rect.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rectangle’s top left corner’s x position.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.rect.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.rect.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rectangle’s top left corner’s y position.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.rect.w">
<span class="sig-name descname"><span class="pre">w</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.rect.w" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rectangle’s width.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.rect.h">
<span class="sig-name descname"><span class="pre">h</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.rect.h" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rectangle’s height.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.rect.magnitude">
<span class="sig-name descname"><span class="pre">magnitude</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.rect.magnitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rectangle’s magnitude.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-qrcode-qrcode-object">
<h2>class QRCode – QRCode object<a class="headerlink" href="#class-qrcode-qrcode-object" title="Permalink to this heading">¶</a></h2>
<p>The qrcode object is returned by <a class="reference internal" href="#image.Image.find_qrcodes" title="image.Image.find_qrcodes"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_qrcodes()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.qrcode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">qrcode</span></span><a class="headerlink" href="#image.qrcode" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.Image.find_qrcodes" title="image.Image.find_qrcodes"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_qrcodes()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.corners">
<span class="sig-name descname"><span class="pre">corners</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 4 (x,y) tuples of the 4 corners of the object. Corners are
always returned in sorted clock-wise order starting from the top left.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.rect">
<span class="sig-name descname"><span class="pre">rect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rectangle tuple (x, y, w, h) for use with other <a class="reference internal" href="#module-image" title="image: machine vision"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">image</span></code></a> methods
like <a class="reference internal" href="#image.Image.draw_rectangle" title="image.Image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_rectangle()</span></code></a> of the qrcode’s bounding box.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the qrcode’s bounding box x coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the qrcode’s bounding box y coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.w">
<span class="sig-name descname"><span class="pre">w</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.w" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the qrcode’s bounding box w coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.h">
<span class="sig-name descname"><span class="pre">h</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.h" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the qrcode’s bounding box h coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.payload">
<span class="sig-name descname"><span class="pre">payload</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the payload string of the qrcode. E.g. the URL.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.version">
<span class="sig-name descname"><span class="pre">version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.version" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the version number of the qrcode (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[5]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.ecc_level">
<span class="sig-name descname"><span class="pre">ecc_level</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.ecc_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ecc_level of the qrcode (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[6]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mask of the qrcode (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[7]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.data_type">
<span class="sig-name descname"><span class="pre">data_type</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.data_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data type of the qrcode (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[8]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.eci">
<span class="sig-name descname"><span class="pre">eci</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.eci" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the eci of the qrcode (int). The eci stores the encoding of data
bytes in the QR Code. If you plan to handling QR Codes that contain more
than just standard ASCII text you will need to look at this value.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[9]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.is_numeric">
<span class="sig-name descname"><span class="pre">is_numeric</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.is_numeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the data_type of the qrcode is numeric.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.is_alphanumeric">
<span class="sig-name descname"><span class="pre">is_alphanumeric</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.is_alphanumeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the data_type of the qrcode is alpha numeric.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.is_binary">
<span class="sig-name descname"><span class="pre">is_binary</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.is_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the data_type of the qrcode is binary. If you are serious
about handling all types of text you need to check the eci if this is True
to determine the text encoding of the data. Usually, it’s just standard
ASCII, but, it could be UTF8 that has some 2-byte characters in it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.qrcode.is_kanji">
<span class="sig-name descname"><span class="pre">is_kanji</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.qrcode.is_kanji" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the data_type of the qrcode is alpha Kanji. If this is True
then you’ll need to decode the string yourself as Kanji symbols are 10-bits
per character and MicroPython has no support to parse this kind of text. The
payload in this case must be treated as just a large byte array.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-apriltag-apriltag-object">
<h2>class AprilTag – AprilTag object<a class="headerlink" href="#class-apriltag-apriltag-object" title="Permalink to this heading">¶</a></h2>
<p>The apriltag object is returned by <a class="reference internal" href="#image.Image.find_apriltags" title="image.Image.find_apriltags"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_apriltags()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.apriltag">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">apriltag</span></span><a class="headerlink" href="#image.apriltag" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.Image.find_apriltags" title="image.Image.find_apriltags"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_apriltags()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.corners">
<span class="sig-name descname"><span class="pre">corners</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 4 (x,y) tuples of the 4 corners of the object. Corners are
always returned in sorted clock-wise order starting from the top left.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.rect">
<span class="sig-name descname"><span class="pre">rect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rectangle tuple (x, y, w, h) for use with other <a class="reference internal" href="#module-image" title="image: machine vision"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">image</span></code></a> methods
like <a class="reference internal" href="#image.Image.draw_rectangle" title="image.Image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_rectangle()</span></code></a> of the apriltag’s bounding box.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the apriltag’s bounding box x coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the apriltag’s bounding box y coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.w">
<span class="sig-name descname"><span class="pre">w</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.w" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the apriltag’s bounding box w coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.h">
<span class="sig-name descname"><span class="pre">h</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.h" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the apriltag’s bounding box h coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.id">
<span class="sig-name descname"><span class="pre">id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the numeric id of the apriltag.</p>
<blockquote>
<div><ul class="simple">
<li><p>TAG16H5 -&gt; 0 to 29</p></li>
<li><p>TAG25H7 -&gt; 0 to 241</p></li>
<li><p>TAG25H9 -&gt; 0 to 34</p></li>
<li><p>TAG36H10 -&gt; 0 to 2319</p></li>
<li><p>TAG36H11 -&gt; 0 to 586</p></li>
<li><p>ARTOOLKIT -&gt; 0 to 511</p></li>
</ul>
</div></blockquote>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.family">
<span class="sig-name descname"><span class="pre">family</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.family" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the numeric family of the apriltag.</p>
<blockquote>
<div><ul class="simple">
<li><p>image.TAG16H5</p></li>
<li><p>image.TAG25H7</p></li>
<li><p>image.TAG25H9</p></li>
<li><p>image.TAG36H10</p></li>
<li><p>image.TAG36H11</p></li>
<li><p>image.ARTOOLKIT</p></li>
</ul>
</div></blockquote>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[5]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.cx">
<span class="sig-name descname"><span class="pre">cx</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.cx" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid x position of the apriltag (int).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.cxf">
<span class="sig-name descname"><span class="pre">cxf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.cxf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid x position of the apriltag (float).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[6]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.cy">
<span class="sig-name descname"><span class="pre">cy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.cy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid y position of the apriltag (int).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.cyf">
<span class="sig-name descname"><span class="pre">cyf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.cyf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid y position of the apriltag (float).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[7]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.rotation">
<span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation of the apriltag in radians (float).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[8]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.decision_margin">
<span class="sig-name descname"><span class="pre">decision_margin</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.decision_margin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the quality of the apriltag match (0.0 - 1.0) where 1.0 is the best.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[9]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.hamming">
<span class="sig-name descname"><span class="pre">hamming</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.hamming" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of accepted bit errors for this tag.</p>
<blockquote>
<div><ul class="simple">
<li><p>TAG16H5 -&gt; 0 bit errors will be accepted</p></li>
<li><p>TAG25H7 -&gt; up to 1 bit error may be accepted</p></li>
<li><p>TAG25H9 -&gt; up to 3 bit errors may be accepted</p></li>
<li><p>TAG36H10 -&gt; up to 3 bit errors may be accepted</p></li>
<li><p>TAG36H11 -&gt; up to 4 bit errors may be accepted</p></li>
<li><p>ARTOOLKIT -&gt; 0 bit errors will be accepted</p></li>
</ul>
</div></blockquote>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[10]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.goodness">
<span class="sig-name descname"><span class="pre">goodness</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.goodness" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the quality of the apriltag image (0.0 - 1.0) where 1.0 is the best.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This value is always 0.0 for now. We may enable a feature called “tag
refinement” in the future which will allow detection of small apriltags.
However, this feature currently drops the frame rate to less than 1 FPS.</p>
</div>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[11]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.x_translation">
<span class="sig-name descname"><span class="pre">x_translation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.x_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the translation in unknown units from the camera in the X direction.</p>
<p>This method is useful for determining the apriltag’s location away from the
camera. However, the size of the apriltag, the lens you are using, etc. all
come into play as to actually determining what the X units are in. For ease
of use we recommend you use a lookup table to convert the output of this
method to something useful for your application.</p>
<p>Note that this is the left-to-right direction.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[12]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.y_translation">
<span class="sig-name descname"><span class="pre">y_translation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.y_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the translation in unknown units from the camera in the Y direction.</p>
<p>This method is useful for determining the apriltag’s location away from the
camera. However, the size of the apriltag, the lens you are using, etc. all
come into play as to actually determining what the Y units are in. For ease
of use we recommend you use a lookup table to convert the output of this
method to something useful for your application.</p>
<p>Note that this is the up-to-down direction.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[13]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.z_translation">
<span class="sig-name descname"><span class="pre">z_translation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.z_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the translation in unknown units from the camera in the Z direction.</p>
<p>This method is useful for determining the apriltag’s location away from the
camera. However, the size of the apriltag, the lens you are using, etc. all
come into play as to actually determining what the Z units are in. For ease
of use we recommend you use a lookup table to convert the output of this
method to something useful for your application.</p>
<p>Note that this is the front-to-back direction.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[14]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.x_rotation">
<span class="sig-name descname"><span class="pre">x_rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.x_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation in radians of the apriltag in the X plane. E.g. moving
the camera left-to-right while looking at the tag.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[15]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.y_rotation">
<span class="sig-name descname"><span class="pre">y_rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.y_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation in radians of the apriltag in the Y plane. E.g. moving
the camera up-to-down while looking at the tag.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[16]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.apriltag.z_rotation">
<span class="sig-name descname"><span class="pre">z_rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.apriltag.z_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation in radians of the apriltag in the Z plane. E.g.
rotating the camera while looking directly at the tag.</p>
<p>Note that this is just a renamed version of <a class="reference internal" href="#image.apriltag.rotation" title="image.apriltag.rotation"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">apriltag.rotation()</span></code></a>.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[17]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-datamatrix-datamatrix-object">
<h2>class DataMatrix – DataMatrix object<a class="headerlink" href="#class-datamatrix-datamatrix-object" title="Permalink to this heading">¶</a></h2>
<p>The datamatrix object is returned by <a class="reference internal" href="#image.Image.find_datamatrices" title="image.Image.find_datamatrices"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_datamatrices()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.datamatrix">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">datamatrix</span></span><a class="headerlink" href="#image.datamatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.Image.find_datamatrices" title="image.Image.find_datamatrices"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_datamatrices()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.corners">
<span class="sig-name descname"><span class="pre">corners</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 4 (x,y) tuples of the 4 corners of the object. Corners are
always returned in sorted clock-wise order starting from the top left.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.rect">
<span class="sig-name descname"><span class="pre">rect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rectangle tuple (x, y, w, h) for use with other <a class="reference internal" href="#module-image" title="image: machine vision"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">image</span></code></a> methods
like <a class="reference internal" href="#image.Image.draw_rectangle" title="image.Image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_rectangle()</span></code></a> of the datamatrix’s bounding box.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the datamatrix’s bounding box x coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the datamatrix’s bounding box y coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.w">
<span class="sig-name descname"><span class="pre">w</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.w" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the datamatrix’s bounding box w coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.h">
<span class="sig-name descname"><span class="pre">h</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.h" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the datamatrix’s bounding box h coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.payload">
<span class="sig-name descname"><span class="pre">payload</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the payload string of the datamatrix. E.g. The string.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.rotation">
<span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation of the datamatrix in radians (float).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[5]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.rows">
<span class="sig-name descname"><span class="pre">rows</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of rows in the data matrix (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[6]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.columns">
<span class="sig-name descname"><span class="pre">columns</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of columns in the data matrix (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[7]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.capacity">
<span class="sig-name descname"><span class="pre">capacity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.capacity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns how many characters could fit in this data matrix.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[8]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.datamatrix.padding">
<span class="sig-name descname"><span class="pre">padding</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.datamatrix.padding" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns how many unused characters are in this data matrix.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[9]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-barcode-barcode-object">
<h2>class BarCode – BarCode object<a class="headerlink" href="#class-barcode-barcode-object" title="Permalink to this heading">¶</a></h2>
<p>The barcode object is returned by <a class="reference internal" href="#image.Image.find_barcodes" title="image.Image.find_barcodes"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_barcodes()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.barcode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">barcode</span></span><a class="headerlink" href="#image.barcode" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.Image.find_barcodes" title="image.Image.find_barcodes"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_barcodes()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.barcode.corners">
<span class="sig-name descname"><span class="pre">corners</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.barcode.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 4 (x,y) tuples of the 4 corners of the object. Corners are
always returned in sorted clock-wise order starting from the top left.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.barcode.rect">
<span class="sig-name descname"><span class="pre">rect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.barcode.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rectangle tuple (x, y, w, h) for use with other <a class="reference internal" href="#module-image" title="image: machine vision"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">image</span></code></a> methods
like <a class="reference internal" href="#image.Image.draw_rectangle" title="image.Image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_rectangle()</span></code></a> of the barcode’s bounding box.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.barcode.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.barcode.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the barcode’s bounding box x coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.barcode.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.barcode.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the barcode’s bounding box y coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.barcode.w">
<span class="sig-name descname"><span class="pre">w</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.barcode.w" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the barcode’s bounding box w coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.barcode.h">
<span class="sig-name descname"><span class="pre">h</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.barcode.h" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the barcode’s bounding box h coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.barcode.payload">
<span class="sig-name descname"><span class="pre">payload</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.barcode.payload" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the payload string of the barcode. E.g. The number.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.barcode.type">
<span class="sig-name descname"><span class="pre">type</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.barcode.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type enumeration of the barcode (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[5]</span></code> on the object.</p>
<blockquote>
<div><ul class="simple">
<li><p>image.EAN2</p></li>
<li><p>image.EAN5</p></li>
<li><p>image.EAN8</p></li>
<li><p>image.UPCE</p></li>
<li><p>image.ISBN10</p></li>
<li><p>image.UPCA</p></li>
<li><p>image.EAN13</p></li>
<li><p>image.ISBN13</p></li>
<li><p>image.I25</p></li>
<li><p>image.DATABAR</p></li>
<li><p>image.DATABAR_EXP</p></li>
<li><p>image.CODABAR</p></li>
<li><p>image.CODE39</p></li>
<li><p>image.PDF417 - Future (e.g. doesn’t work right now).</p></li>
<li><p>image.CODE93</p></li>
<li><p>image.CODE128</p></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.barcode.rotation">
<span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.barcode.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation of the barcode in radians (float).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[6]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.barcode.quality">
<span class="sig-name descname"><span class="pre">quality</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.barcode.quality" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of times this barcode was detected in the image (int).</p>
<p>When scanning a barcode each new scanline can decode the same barcode. This
value increments for a barcode each time that happens…</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[7]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-displacement-displacement-object">
<h2>class Displacement – Displacement object<a class="headerlink" href="#class-displacement-displacement-object" title="Permalink to this heading">¶</a></h2>
<p>The displacement object is returned by <a class="reference internal" href="#image.Image.find_displacement" title="image.Image.find_displacement"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_displacement()</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.displacement">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">displacement</span></span><a class="headerlink" href="#image.displacement" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.Image.find_displacement" title="image.Image.find_displacement"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_displacement()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.displacement.x_translation">
<span class="sig-name descname"><span class="pre">x_translation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.displacement.x_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the x translation in pixels between two images. This is sub pixel
accurate so it’s a float.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.displacement.y_translation">
<span class="sig-name descname"><span class="pre">y_translation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.displacement.y_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the y translation in pixels between two images. This is sub pixel
accurate so it’s a float.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.displacement.rotation">
<span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.displacement.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation in radians between two images.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.displacement.scale">
<span class="sig-name descname"><span class="pre">scale</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.displacement.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the scale change between two images.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.displacement.response">
<span class="sig-name descname"><span class="pre">response</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.displacement.response" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the quality of the results of displacement matching between two images.
Between 0-1. A <code class="docutils literal notranslate"><span class="pre">displacement</span></code> object with a response less than 0.1 is likely noise.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-kptmatch-keypoint-object">
<h2>class kptmatch – Keypoint Object<a class="headerlink" href="#class-kptmatch-keypoint-object" title="Permalink to this heading">¶</a></h2>
<p>The kptmatch object is returned by <a class="reference internal" href="#image.match_descriptor" title="image.match_descriptor"><code class="xref any py py-func docutils literal notranslate"><span class="pre">image.match_descriptor()</span></code></a> for keypoint matches.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.kptmatch">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">kptmatch</span></span><a class="headerlink" href="#image.kptmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Please call <a class="reference internal" href="#image.match_descriptor" title="image.match_descriptor"><code class="xref any py py-func docutils literal notranslate"><span class="pre">image.match_descriptor()</span></code></a> to create this object.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.kptmatch.rect">
<span class="sig-name descname"><span class="pre">rect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.kptmatch.rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rectangle tuple (x, y, w, h) for use with other <a class="reference internal" href="#module-image" title="image: machine vision"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">image</span></code></a> methods
like <a class="reference internal" href="#image.Image.draw_rectangle" title="image.Image.draw_rectangle"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.draw_rectangle()</span></code></a> of the kptmatch’s bounding box.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.kptmatch.cx">
<span class="sig-name descname"><span class="pre">cx</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.kptmatch.cx" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid x position of the kptmatch (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[0]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.kptmatch.cy">
<span class="sig-name descname"><span class="pre">cy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.kptmatch.cy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid y position of the kptmatch (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[1]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.kptmatch.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.kptmatch.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the kptmatch’s bounding box x coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[2]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.kptmatch.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.kptmatch.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the kptmatch’s bounding box y coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[3]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.kptmatch.w">
<span class="sig-name descname"><span class="pre">w</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.kptmatch.w" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the kptmatch’s bounding box w coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[4]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.kptmatch.h">
<span class="sig-name descname"><span class="pre">h</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.kptmatch.h" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the kptmatch’s bounding box h coordinate (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[5]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.kptmatch.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.kptmatch.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of keypoints matched (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[6]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.kptmatch.theta">
<span class="sig-name descname"><span class="pre">theta</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.kptmatch.theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the estimated angle of rotation for the keypoint (int).</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[7]</span></code> on the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.kptmatch.match">
<span class="sig-name descname"><span class="pre">match</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.kptmatch.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of (x,y) tuples of matching keypoints.</p>
<p>You may also get this value doing <code class="docutils literal notranslate"><span class="pre">[8]</span></code> on the object.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-imageio-imageio-object">
<h2>class ImageIO  – ImageIO Object<a class="headerlink" href="#class-imageio-imageio-object" title="Permalink to this heading">¶</a></h2>
<p>The ImageIO object allows you to read/write OpenMV Image objects in their native form to disk
or to memory. This class provides fast read/write random access for loading/storing images.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.ImageIO">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">ImageIO</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an ImageIO object.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">path</span></code> is a file name on disk then that file will be opened for reading if <code class="docutils literal notranslate"><span class="pre">mode</span></code> is <code class="docutils literal notranslate"><span class="pre">'r'</span></code>
or writing if <code class="docutils literal notranslate"><span class="pre">mode</span></code> is <code class="docutils literal notranslate"><span class="pre">'w'</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">path</span></code> may also be a 3-value tuple (w, h, bpp) for in-memory storage of images. <code class="docutils literal notranslate"><span class="pre">mode</span></code> in
this case is then the number of image buffers to store in memory. Note that the in-memory
storage buffer is not allowed to grow in size after being allocated. Use a <code class="docutils literal notranslate"><span class="pre">bpp</span></code> value of
0 for binary images, 1 for grayscale images, and 2 for rgb565 images.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.type">
<span class="sig-name descname"><span class="pre">type</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if the <a class="reference internal" href="#image.ImageIO" title="image.ImageIO"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ImageIO</span></code></a> object is a <a class="reference internal" href="#image.ImageIO.FILE_STREAM" title="image.ImageIO.FILE_STREAM"><code class="xref any py py-data docutils literal notranslate"><span class="pre">FILE_STREAM</span></code></a> or <a class="reference internal" href="#image.ImageIO.MEMORY_STREAM" title="image.ImageIO.MEMORY_STREAM"><code class="xref any py py-data docutils literal notranslate"><span class="pre">MEMORY_STREAM</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.is_closed">
<span class="sig-name descname"><span class="pre">is_closed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.is_closed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if the <a class="reference internal" href="#image.ImageIO" title="image.ImageIO"><code class="xref any py py-class docutils literal notranslate"><span class="pre">ImageIO</span></code></a> object is closed and can no longer be used.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of frames stored.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.offset">
<span class="sig-name descname"><span class="pre">offset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the image index offset.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.version">
<span class="sig-name descname"><span class="pre">version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.version" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the version of the object if it’s <a class="reference internal" href="#image.ImageIO.FILE_STREAM" title="image.ImageIO.FILE_STREAM"><code class="xref any py py-data docutils literal notranslate"><span class="pre">FILE_STREAM</span></code></a>.
<a class="reference internal" href="#image.ImageIO.MEMORY_STREAM" title="image.ImageIO.MEMORY_STREAM"><code class="xref any py py-data docutils literal notranslate"><span class="pre">MEMORY_STREAM</span></code></a> versions are <code class="docutils literal notranslate"><span class="pre">none</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.buffer_size">
<span class="sig-name descname"><span class="pre">buffer_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.buffer_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size allocated by the object for a frame in a single buffer.</p>
<p><code class="docutils literal notranslate"><span class="pre">buffer_size()</span> <span class="pre">*</span> <span class="pre">count()</span> <span class="pre">==</span> <span class="pre">size()</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bytes on disk or memory used by the ImageIO object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes a new image <code class="docutils literal notranslate"><span class="pre">img</span></code> to the ImageIO object. For on disk ImageIO objects the file will
grow as new images are added. For in-memory ImageIO objects this just writes an image to the
current pre-allocated slot before advancing to the next slot.</p>
<p>Returns the ImageIO object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">copy_to_fb=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">loop=True</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pause=True</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an image object from the ImageIO object. If <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> is False then
the new image is allocated on the MicroPython heap. However, the MicroPython heap is limited
and may not have space to store the new image if exhausted. Instead, set <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> to
True to set the frame buffer to the new image making this function work just like <a class="reference internal" href="omv.sensor.html#sensor.snapshot" title="sensor.snapshot"><code class="xref any py py-func docutils literal notranslate"><span class="pre">sensor.snapshot()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">loop</span></code> if True automatically causes the ImageIO object to seek to the beginning at the end
of the stream of images.</p>
<p><code class="docutils literal notranslate"><span class="pre">pause</span></code> if True causes this method to pause for a previously recorded number of milliseconds
by write in-order to match the original frame rate that captured the image data.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> may also be another image object if you want to replace that image object’s memory
buffer, type, width, and height with new image data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Any use of <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> invalidates the previous image object it overwrites. Do not use
any references to previous image objects anymore it overwrites. Either for an image object
referencing the frame buffer, frame buffer stack, or an image on the MicroPython heap.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.seek">
<span class="sig-name descname"><span class="pre">seek</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.seek" title="Permalink to this definition">¶</a></dt>
<dd><p>Seeks to the image slot number <code class="docutils literal notranslate"><span class="pre">offset</span></code> in the ImageIO object.</p>
<p>Works for on disk or in-memory objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.sync">
<span class="sig-name descname"><span class="pre">sync</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.sync" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes out all data pending for on-disk ImageIO objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.ImageIO.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.ImageIO.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the ImageIO object. For in-memory objects this free’s the allocated space and for
on-disk files this closes the file and writes out all meta-data.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.ImageIO.FILE_STREAM">
<span class="sig-name descname"><span class="pre">FILE_STREAM</span></span><a class="headerlink" href="#image.ImageIO.FILE_STREAM" title="Permalink to this definition">¶</a></dt>
<dd><p>ImageIO object was opened on a file.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.ImageIO.MEMORY_STREAM">
<span class="sig-name descname"><span class="pre">MEMORY_STREAM</span></span><a class="headerlink" href="#image.ImageIO.MEMORY_STREAM" title="Permalink to this definition">¶</a></dt>
<dd><p>iamgeIO object was opened in memory.</p>
</dd></dl>

</dd></dl>

</section>
<section id="class-image-image-object">
<h2>class Image – Image object<a class="headerlink" href="#class-image-image-object" title="Permalink to this heading">¶</a></h2>
<p>The image object is the basic object for machine vision operations.</p>
<dl class="py class">
<dt class="sig sig-object py" id="image.Image">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">Image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy_to_fb=False</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new image object from a file at <code class="docutils literal notranslate"><span class="pre">path</span></code>. Alternatively, you may
pass a width, height, and either <a class="reference internal" href="omv.sensor.html#sensor.BINARY" title="sensor.BINARY"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.BINARY</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.GRAYSCALE" title="sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a>, or
<a class="reference internal" href="omv.sensor.html#sensor.RGB565" title="sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> to create new blank image object (initialized to 0 - black).</p>
<p>Supports bmp/pgm/ppm/jpg/jpeg image files.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> if True the image is loaded directly into the frame buffer
allowing you to load up large images. If False, the image is loaded into
MicroPython’s heap which is much smaller than the frame buffer.</p>
<p>You may also set <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> equal to another image object and that
buffer will then be overwritten with the copied image changing the passed
image object’s pixel format and resolution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> is set to True or another image object do not continue
using the old image object passed to this method or the frame buffer
image object. Use the new returned image object reference from this
method as the old references are now stale.</p>
</div>
<p>Images support “[]” notation. Do <code class="docutils literal notranslate"><span class="pre">image[index]</span> <span class="pre">=</span> <span class="pre">8/16-bit</span> <span class="pre">value</span></code> to assign
an image pixel or <code class="docutils literal notranslate"><span class="pre">image[index]</span></code> to get an image pixel which will be
either an 8-bit value for grayscale images of a 16-bit RGB565 value for RGB
images.</p>
<p>For JPEG images the “[]” allows you to access the compressed JPEG image blob
as a byte-array. Reading and writing to the data array is opaque however as
JPEG images are compressed byte streams.</p>
<p>Images also support read buffer operations. You can pass images to all sorts
of MicroPython functions like as if the image were a byte-array object. In
particular, if you’d like to transmit an image you can just pass it to the
UART/SPI/I2C write functions to be transmitted automatically.</p>
<dl class="py method">
<dt class="sig sig-object py" id="image.Image.width">
<span class="sig-name descname"><span class="pre">width</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the image width in pixels.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.height">
<span class="sig-name descname"><span class="pre">height</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.height" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the image height in pixels.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.format">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <a class="reference internal" href="omv.sensor.html#sensor.GRAYSCALE" title="sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a> for grayscale images, <a class="reference internal" href="omv.sensor.html#sensor.RGB565" title="sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> for RGB565
images, <a class="reference internal" href="omv.sensor.html#sensor.BAYER" title="sensor.BAYER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.BAYER</span></code></a> for bayer pattern images, and <a class="reference internal" href="omv.sensor.html#sensor.JPEG" title="sensor.JPEG"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.JPEG</span></code></a> for JPEG
images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the image size in bytes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.bytearray">
<span class="sig-name descname"><span class="pre">bytearray</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.bytearray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#image.Image.bytearray" title="image.Image.bytearray"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">bytearray</span></code></a> object that points to the image data for byte-level read/write access.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Image objects are automatically cast as <a class="reference internal" href="builtins.html#bytes" title="bytes"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> objects when passed to MicroPython driver
that requires a <a class="reference internal" href="builtins.html#bytes" title="bytes"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> like object. This is read-only access.
Call <a class="reference internal" href="#image.Image.bytearray" title="image.Image.bytearray"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">bytearray()</span></code></a> to get read/write access.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.get_pixel">
<span class="sig-name descname"><span class="pre">get_pixel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgbtuple</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.get_pixel" title="Permalink to this definition">¶</a></dt>
<dd><p>For grayscale images: Returns the grayscale pixel value at location (x, y).
For RGB565 images: Returns the RGB888 pixel tuple (r, g, b) at location (x, y).
For bayer pattern images: Returns the the pixel value at the location (x, y).</p>
<p>Returns None if <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> is outside of the image.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> may either be passed independently or as a tuple.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgbtuple</span></code> if True causes this method to return an RGB888 tuple. Otherwise,
this method returns the integer value of the underlying pixel. I.e. for RGB565
images this method returns a RGB565 value. Defaults to True
for RGB565 images and False otherwise.</p>
<p>Not supported on compressed images.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#image.Image.get_pixel" title="image.Image.get_pixel"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.get_pixel()</span></code></a> and <a class="reference internal" href="#image.Image.set_pixel" title="image.Image.set_pixel"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.set_pixel()</span></code></a> are the only methods that allow
you to manipulate bayer pattern images. Bayer pattern images are literal images
where pixels in the image are R/G/R/G/etc. for even rows and G/B/G/B/etc. for
odd rows. Each pixel is 8-bits. If you call this method with <code class="docutils literal notranslate"><span class="pre">rgbtuple</span></code> set then <a class="reference internal" href="#image.Image.get_pixel" title="image.Image.get_pixel"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.get_pixel()</span></code></a>
will debayer the source image at that pixel location and return a valid RGB888 tuple for the pixel location.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.set_pixel">
<span class="sig-name descname"><span class="pre">set_pixel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.set_pixel" title="Permalink to this definition">¶</a></dt>
<dd><p>For grayscale images: Sets the pixel at location (x, y) to the grayscale value <code class="docutils literal notranslate"><span class="pre">pixel</span></code>.
For RGB565 images: Sets the pixel at location (x, y) to the RGB888 tuple (r, g, b) <code class="docutils literal notranslate"><span class="pre">pixel</span></code>.
For bayer pattern images: Sets the pixel value at the location (x, y) to the value <code class="docutils literal notranslate"><span class="pre">pixel</span></code>.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> may either be passed independently or as a tuple.</p>
<p><code class="docutils literal notranslate"><span class="pre">pixel</span></code> may either be an RGB888 tuple (r, g, b) or the underlying pixel
value (i.e. a RGB565 value for RGB565 images or an 8-bit value
for grayscale images.</p>
<p>Not supported on compressed images.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#image.Image.get_pixel" title="image.Image.get_pixel"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.get_pixel()</span></code></a> and <a class="reference internal" href="#image.Image.set_pixel" title="image.Image.set_pixel"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.set_pixel()</span></code></a> are the only methods that allow
you to manipulate bayer pattern images. Bayer pattern images are literal images
where pixels in the image are R/G/R/G/etc. for even rows and G/B/G/B/etc. for
odd rows. Each pixel is 8-bits. If you call this method with an RGB888 tuple the grayscale
value of that RGB888 tuple is extracted and set to the pixel location.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.mean_pool">
<span class="sig-name descname"><span class="pre">mean_pool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_div</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_div</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.mean_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the mean of <code class="docutils literal notranslate"><span class="pre">x_div</span></code> * <code class="docutils literal notranslate"><span class="pre">y_div</span></code> squares in the image and returns
the modified image composed of the mean of each square.</p>
<p>This method allows you to shrink an image down very quickly in-place.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.mean_pooled">
<span class="sig-name descname"><span class="pre">mean_pooled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_div</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_div</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.mean_pooled" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the mean of <code class="docutils literal notranslate"><span class="pre">x_div</span></code> * <code class="docutils literal notranslate"><span class="pre">y_div</span></code> squares in the image and returns
a new image composed of the mean of each square.</p>
<p>This method allows you to create a shrunken down image copy.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.midpoint_pool">
<span class="sig-name descname"><span class="pre">midpoint_pool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_div</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_div</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">bias=0.5</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.midpoint_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the midpoint of <code class="docutils literal notranslate"><span class="pre">x_div</span></code> * <code class="docutils literal notranslate"><span class="pre">y_div</span></code> squares in the image and returns
the modified image composed of the midpoint of each square.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">bias</span></code> of 0.0 returns the min of each area while a <code class="docutils literal notranslate"><span class="pre">bias</span></code> of 1.0 returns
the max of each area.</p>
<p>This method allows you to shrink an image down very quickly in-place.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.midpoint_pooled">
<span class="sig-name descname"><span class="pre">midpoint_pooled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_div</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_div</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">bias=0.5</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.midpoint_pooled" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the midpoint of <code class="docutils literal notranslate"><span class="pre">x_div</span></code> * <code class="docutils literal notranslate"><span class="pre">y_div</span></code> squares in the image and returns
a new image composed of the midpoint of each square.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">bias</span></code> of 0.0 returns the min of each area while a <code class="docutils literal notranslate"><span class="pre">bias</span></code> of 1.0 returns
the max of each area.</p>
<p>This method allows you to create a shrunken down image copy.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.to_bitmap">
<span class="sig-name descname"><span class="pre">to_bitmap</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.to_bitmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an image to a bitmap image (1 bit per pixel). If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is False
this method will try to modify the image in-place. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is True then
this method will return a new image copy allocated on the heap.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> may also be another image object, which in this case this method will try to
re-use that image objects storage space and will return a new image object that uses
the previous image objects storage space. After doing this do not use any references
to the old image object anymore as they will be stale.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Bitmap images are like grayscale images with only two pixels values - 0
and 1. Additionally, bitmap images are packed such that they only store
1 bit per pixel making them very small. The OpenMV image library allows
bitmap images to be used in all places <a class="reference internal" href="omv.sensor.html#sensor.GRAYSCALE" title="sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a> and <a class="reference internal" href="omv.sensor.html#sensor.RGB565" title="sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> images
can be used. However, many operations when applied on bitmap images don’t
make any sense becuase bitmap images only have 2 values. OpenMV recommends
using bitmap images for <code class="docutils literal notranslate"><span class="pre">mask</span></code> values in operations and such as they
fit on the MicroPython heap quite easily. Finally, bitmap image pixel values
0 and 1 are interpreted as black and white when being applied to <a class="reference internal" href="omv.sensor.html#sensor.GRAYSCALE" title="sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a>
or <a class="reference internal" href="omv.sensor.html#sensor.RGB565" title="sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> images. The library automatically handles conversion.</p>
</div>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.to_grayscale">
<span class="sig-name descname"><span class="pre">to_grayscale</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.to_grayscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an image to a grayscale image (8-bits per pixel). If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is False
this method will try to modify the image in-place. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is True then
this method will return a new image copy allocated on the heap.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> may also be another image object, which in this case this method will try to
re-use that image objects storage space and will return a new image object that uses
the previous image objects storage space. After doing this do not use any references
to the old image object anymore as they will be stale.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.to_rgb565">
<span class="sig-name descname"><span class="pre">to_rgb565</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.to_rgb565" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an image to an RGB565 image (16-bits per pixel). If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is False
this method will try to modify the image in-place. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is True then
this method will return a new image copy allocated on the heap.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> may also be another image object, which in this case this method will try to
re-use that image objects storage space and will return a new image object that uses
the previous image objects storage space. After doing this do not use any references
to the old image object anymore as they will be stale.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.to_rainbow">
<span class="sig-name descname"><span class="pre">to_rainbow</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=sensor.PALETTE_RAINBOW</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.to_rainbow" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an image to an RGB565 rainbow image (16-bits per pixel). If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is False
this method will try to modify the image in-place. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is True then
this method will return a new image copy allocated on the heap.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> may also be another image object, which in this case this method will try to
re-use that image objects storage space and will return a new image object that uses
the previous image objects storage space. After doing this do not use any references
to the old image object anymore as they will be stale.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.to_ironbow">
<span class="sig-name descname"><span class="pre">to_ironbow</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=sensor.PALETTE_IRONBOW</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.to_ironbow" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an image to an RGB565 ironbow image (16-bits per pixel). If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is False
this method will try to modify the image in-place. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is True then
this method will return a new image copy allocated on the heap.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> may also be another image object, which in this case this method will try to
re-use that image objects storage space and will return a new image object that uses
the previous image objects storage space. After doing this do not use any references
to the old image object anymore as they will be stale.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.to_jpeg">
<span class="sig-name descname"><span class="pre">to_jpeg</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.to_jpeg" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an image to a JPEG image. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is False
this method will try to modify the image in-place. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is True then
this method will return a new image copy allocated on the heap.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> may also be another image object, which in this case this method will try to
re-use that image objects storage space and will return a new image object that uses
the previous image objects storage space. After doing this do not use any references
to the old image object anymore as they will be stale.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.to_png">
<span class="sig-name descname"><span class="pre">to_png</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.to_png" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an image to a PNG image. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is False
this method will try to modify the image in-place. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is True then
this method will return a new image copy allocated on the heap.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> may also be another image object, which in this case this method will try to
re-use that image objects storage space and will return a new image object that uses
the previous image objects storage space. After doing this do not use any references
to the old image object anymore as they will be stale.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.compress">
<span class="sig-name descname"><span class="pre">compress</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">quality=90</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>JPEG compresses the image in place. Use this method versus <a class="reference internal" href="#image.Image.compressed" title="image.Image.compressed"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.compressed()</span></code></a>
to save heap space and to use a higher <code class="docutils literal notranslate"><span class="pre">quality</span></code> for compression at the
cost of destroying the original image.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p><code class="docutils literal notranslate"><span class="pre">quality</span></code> is the compression quality (0-100) (int).</p>
<p>Returns the compressed image if called on a compressed image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.compress_for_ide">
<span class="sig-name descname"><span class="pre">compress_for_ide</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">quality=90</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.compress_for_ide" title="Permalink to this definition">¶</a></dt>
<dd><p>JPEG compresses the image in place. Use this method versus <a class="reference internal" href="#image.Image.compressed" title="image.Image.compressed"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.compressed()</span></code></a>
to save heap space and to use a higher <code class="docutils literal notranslate"><span class="pre">quality</span></code> for compression at the
cost of destroying the original image.</p>
<p>This method JPEG compresses the image and then formats the JPEG data for
transmission to OpenMV IDE to display by encoding every 6-bits as a byte
valued between 128-191. This is done to prevent JPEG data from being
misinterpreted as other text data in the byte stream.</p>
<p>You need to use this method to format image data for display to terminal
windows created via “Open Terminal” in OpenMV IDE.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p><code class="docutils literal notranslate"><span class="pre">quality</span></code> is the compression quality (0-100) (int).</p>
<p>Returns the image compressed for the IDE if called on a compressed image.
Do not call this on an image already compressed for the IDE.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.compressed">
<span class="sig-name descname"><span class="pre">compressed</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">quality=90</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.compressed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a JPEG compressed image - the original image is untouched. However,
this method requires a somewhat large allocation of heap space so the image
compression quality must be lower and the image resolution must be lower
than what you could do with <a class="reference internal" href="#image.Image.compress" title="image.Image.compress"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.compress()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">quality</span></code> is the compression quality (0-100) (int).</p>
<p>Returns a compressed image copy if called on a compressed image.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.compressed_for_ide">
<span class="sig-name descname"><span class="pre">compressed_for_ide</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">quality=90</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.compressed_for_ide" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a JPEG compressed image - the original image is untouched. However,
this method requires a somewhat large allocation of heap space so the image
compression quality must be lower and the image resolution must be lower
than what you could do with <a class="reference internal" href="#image.Image.compress" title="image.Image.compress"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.compress()</span></code></a>.</p>
<p>This method JPEG compresses the image and then formats the JPEG data for
transmission to OpenMV IDE to display by encoding every 6-bits as a byte
valued between 128-191. This is done to prevent JPEG data from being
misinterpreted as other text data in the byte stream.</p>
<p>You need to use this method to format image data for display to terminal
windows created via “Open Terminal” in OpenMV IDE.</p>
<p><code class="docutils literal notranslate"><span class="pre">quality</span></code> is the compression quality (0-100) (int).</p>
<p>Returns a image compressed for the IDE copy if called on a compressed image.
Do not call this on an image already compressed for the IDE.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy_to_fb=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a deep copy of the image object. If <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> is False then
the new image is allocated on the MicroPython heap. However, the MicroPython heap is limited
and may not have space to store the new image if exhausted. Instead, set <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> to
True to set the frame buffer to the new image making this function work just like <a class="reference internal" href="omv.sensor.html#sensor.snapshot" title="sensor.snapshot"><code class="xref any py py-func docutils literal notranslate"><span class="pre">sensor.snapshot()</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> may also be another image object if you want to replace that image object’s memory
buffer, type, width, and height with new image data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Any use of <code class="docutils literal notranslate"><span class="pre">copy_to_fb</span></code> invalidates the previous image object it overwrites. Do not use
any references to previous image objects anymore it overwrites. Either for an image object
referencing the frame buffer, frame buffer stack, or an image on the MicroPython heap.</p>
</div>
<p>Returns the new image object.</p>
<p>Not supported on compressed images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.crop">
<span class="sig-name descname"><span class="pre">crop</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies an image in-place without changing the underlying image type. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is False
this method will try to modify the image in-place. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is True then
this method will return a new image copy allocated on the heap.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> may also be another image object, which in this case this method will try to
re-use that image objects storage space and will return a new image object that uses
the previous image objects storage space. After doing this do not use any references
to the old image object anymore as they will be stale.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.scale">
<span class="sig-name descname"><span class="pre">scale</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies an image in-place without changing the underlying image type. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is False
this method will try to modify the image in-place. If <code class="docutils literal notranslate"><span class="pre">copy</span></code> is True then
this method will return a new image copy allocated on the heap.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> may also be another image object, which in this case this method will try to
re-use that image objects storage space and will return a new image object that uses
the previous image objects storage space. After doing this do not use any references
to the old image object anymore as they will be stale.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">quality=50</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves a copy of the image to the filesystem at <code class="docutils literal notranslate"><span class="pre">path</span></code>.</p>
<p>Supports bmp/pgm/ppm/jpg/jpeg image files. Note that you cannot save jpeg
compressed images to an uncompressed format.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle (x, y, w, h) to save from.
If not specified, it is equal to the image rectangle which copies the entire
image. This argument is not applicable for JPEG images.</p>
<p><code class="docutils literal notranslate"><span class="pre">quality</span></code> is the jpeg compression quality to use to save the image to jpeg
format if the image is not already compressed (0-100) (int).</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.flush">
<span class="sig-name descname"><span class="pre">flush</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the frame buffer in the IDE with the image in the frame buffer on the camera.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">mask</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets all pixels in the image to zero (very fast).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.draw_line">
<span class="sig-name descname"><span class="pre">draw_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">thickness=1</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.draw_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a line from (x0, y0) to (x1, y1) on the image. You may either
pass x0, y0, x1, y1 separately or as a tuple (x0, y0, x1, y1).</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> is an RGB888 tuple for Grayscale or RGB565 images. Defaults to
white. However, you may also pass the underlying pixel value (0-255) for
grayscale images or a RGB565 value for RGB565 images.</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> controls how thick the line is in pixels.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.draw_rectangle">
<span class="sig-name descname"><span class="pre">draw_rectangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">thickness=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fill=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.draw_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a rectangle on the image. You may either pass x, y, w, h separately
or as a tuple (x, y, w, h).</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> is an RGB888 tuple for Grayscale or RGB565 images. Defaults to
white. However, you may also pass the underlying pixel value (0-255) for
grayscale images or a RGB565 value for RGB565 images.</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> controls how thick the lines are in pixels.</p>
<p>Pass <code class="docutils literal notranslate"><span class="pre">fill</span></code> set to True to fill the rectangle.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.draw_circle">
<span class="sig-name descname"><span class="pre">draw_circle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">thickness=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fill=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.draw_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a circle on the image. You may either pass x, y, radius separately or
as a tuple (x, y, radius).</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> is an RGB888 tuple for Grayscale or RGB565 images. Defaults to
white. However, you may also pass the underlying pixel value (0-255) for
grayscale images or a RGB565 value for RGB565 images.</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> controls how thick the edges are in pixels.</p>
<p>Pass <code class="docutils literal notranslate"><span class="pre">fill</span></code> set to True to fill the circle.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.draw_ellipse">
<span class="sig-name descname"><span class="pre">draw_ellipse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">thickness=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fill=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.draw_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws an ellipse on the image. You may either pass cx, cy, rx, ry, and the
rotation (in degrees) separately or as a tuple (cx, yc, rx, ry, rotation).</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> is an RGB888 tuple for Grayscale or RGB565 images. Defaults to
white. However, you may also pass the underlying pixel value (0-255) for
grayscale images or a RGB565 value for RGB565 images.</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> controls how thick the edges are in pixels.</p>
<p>Pass <code class="docutils literal notranslate"><span class="pre">fill</span></code> set to True to fill the ellipse.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.draw_string">
<span class="sig-name descname"><span class="pre">draw_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">scale=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_spacing=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_spacing=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mono_space=True</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">char_rotation=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">char_hmirror=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">char_vflip=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">string_rotation=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">string_hmirror=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">string_vflip=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.draw_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws 8x10 text starting at location (x, y) in the image. You may either pass
x, y separately or as a tuple (x, y).</p>
<p><code class="docutils literal notranslate"><span class="pre">text</span></code> is a string to write to the image. <code class="docutils literal notranslate"><span class="pre">\n</span></code>, <code class="docutils literal notranslate"><span class="pre">\r</span></code>, and <code class="docutils literal notranslate"><span class="pre">\r\n</span></code>
line endings move the cursor to the next line.</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> is an RGB888 tuple for Grayscale or RGB565 images. Defaults to
white. However, you may also pass the underlying pixel value (0-255) for
grayscale images or a RGB565 value for RGB565 images.</p>
<p><code class="docutils literal notranslate"><span class="pre">scale</span></code> may be increased to increase/decrease the size of the text on the
image. You can pass greater than 0 integer or floating point values.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_spacing</span></code> allows you to add (if positive) or subtract (if negative) x
pixels between cahracters.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_spacing</span></code> allows you to add (if positive) or subtract (if negative) y
pixels between cahracters (for multi-line text).</p>
<p><code class="docutils literal notranslate"><span class="pre">mono_space</span></code> defaults to True which forces text to be fixed spaced. For
large text scales this looks terrible. Set the False to get non-fixed width
character spacing which looks A LOT better.</p>
<p><code class="docutils literal notranslate"><span class="pre">char_rotation</span></code> may be 0, 90, 180, 270 to rotate each character in the
string by this amount.</p>
<p><code class="docutils literal notranslate"><span class="pre">char_hmirror</span></code> if True horizontally mirrors all characters in the string.</p>
<p><code class="docutils literal notranslate"><span class="pre">char_vflip</span></code> if True vertically flips all characters in the string.</p>
<p><code class="docutils literal notranslate"><span class="pre">string_rotation</span></code> may be 0, 90, 180, 270 to rotate the string by this
amount.</p>
<p><code class="docutils literal notranslate"><span class="pre">string_hmirror</span></code> if True horizontally mirrors the string.</p>
<p><code class="docutils literal notranslate"><span class="pre">string_vflip</span></code> if True vertically flips the string.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.draw_cross">
<span class="sig-name descname"><span class="pre">draw_cross</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">size=5</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">thickness=1</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.draw_cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a cross at location x, y. You may either pass x, y separately or as a
tuple (x, y).</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> is an RGB888 tuple for Grayscale or RGB565 images. Defaults to
white. However, you may also pass the underlying pixel value (0-255) for
grayscale images or a RGB565 value for RGB565 images.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> controls how long the lines of the cross extend.</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> controls how thick the edges are in pixels.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.draw_arrow">
<span class="sig-name descname"><span class="pre">draw_arrow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">thickness=1</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.draw_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws an arrow from (x0, y0) to (x1, y1) on the image. You may
either pass x0, y0, x1, y1 separately or as a tuple (x0, y0, x1, y1).</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> is an RGB888 tuple for Grayscale or RGB565 images. Defaults to
white. However, you may also pass the underlying pixel value (0-255) for
grayscale images or a RGB565 value for RGB565 images.</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> controls how thick the line is in pixels.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.draw_edges">
<span class="sig-name descname"><span class="pre">draw_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">corners</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">size=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">thickness=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fill=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.draw_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws line edges between a corner list returned by methods like <a class="reference internal" href="#image.blob.corners" title="image.blob.corners"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">blob.corners</span></code></a>. Coners is
a four valued tuple of two valued x/y tuples. E.g. [(x1,y1),(x2,y2),(x3,y3),(x4,y4)].</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> is an RGB888 tuple for Grayscale or RGB565 images. Defaults to
white. However, you may also pass the underlying pixel value (0-255) for
grayscale images or a RGB565 value for RGB565 images.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> if greater than 0 causes the corners to be drawn as circles of radius <code class="docutils literal notranslate"><span class="pre">size</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> controls how thick the line is in pixels.</p>
<p>Pass <code class="docutils literal notranslate"><span class="pre">fill</span></code> set to True to fill the corner circles if drawn.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.draw_image">
<span class="sig-name descname"><span class="pre">draw_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_scale=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rgb_channel=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=256</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha_palette=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hint=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_size=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_size=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.draw_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws an <code class="docutils literal notranslate"><span class="pre">image</span></code> whose top-left corner starts at location x, y. You may either pass x, y
separately or as a tuple (x, y). This method automatically handles rendering the image passed
into the correct pixel format for the destination image while also handling clipping seamlessly.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_scale</span></code> controls how much the drawn image is scaled by in the x direction (float). If this
value is negative the image will be flipped horizontally.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_scale</span></code> controls how much the drawn image is scaled by in the y direction (float). If this
value is negative the image will be flipped vertically.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h) of the source image to draw. This
allows you to extract just the pixels in the ROI to scale and draw on the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> is the RGB channel (0=R, G=1, B=2) to extract from an RGB565 image (if passed)
and to render onto the destination image. For example, if you pass <code class="docutils literal notranslate"><span class="pre">rgb_channel=1</span></code> this will
extract the green channel of the source RGB565 image and draw that in grayscale on the
destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the source image to blend into the destination image. A value of
256 draws an opaque source image while a value lower than 256 produces a blend between the source
and destination image. 0 results in no modification to the destination image.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_RAINBOW" title="sensor.PALETTE_RAINBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_RAINBOW</span></code></a>, <a class="reference internal" href="omv.sensor.html#sensor.PALETTE_IRONBOW" title="sensor.PALETTE_IRONBOW"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.PALETTE_IRONBOW</span></code></a>, or
a 256 pixel in total RGB565 image to use as a color lookup table on the grayscale value of
whatever the source image is. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha_palette</span></code> if not <code class="docutils literal notranslate"><span class="pre">-1</span></code> can be a 256 pixel in total GRAYSCALE image to use as a alpha
palette which modulates the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> value of the source image being drawn at a pixel pixel
level allowing you to precisely control the alpha value of pixels based on their grayscale value.
A pixel value of 255 in the alpha lookup table is opaque which anything less than 255 becomes
more transparent until 0. This is applied after <code class="docutils literal notranslate"><span class="pre">rgb_channel</span></code> extraction if used.</p>
<p><code class="docutils literal notranslate"><span class="pre">hint</span></code> can be a logical OR of the flags:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a>: Use area scaling when downscaling versus the default of nearest neighbor.</p></li>
<li><p><a class="reference internal" href="#image.BILINEAR" title="image.BILINEAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BILINEAR</span></code></a>: Use bilinear scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.BICUBIC" title="image.BICUBIC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BICUBIC</span></code></a>: Use bicubic scaling versus the default of nearest neighbor scaling.</p></li>
<li><p><a class="reference internal" href="#image.CENTER" title="image.CENTER"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CENTER</span></code></a>: Center the image image being draw on (x, y).</p></li>
<li><p><a class="reference internal" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="image.EXTRACT_RGB_CHANNEL_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EXTRACT_RGB_CHANNEL_FIRST</span></code></a>: Do rgb_channel extraction before scaling.</p></li>
<li><p><a class="reference internal" href="#image.APPLY_COLOR_PALETTE_FIRST" title="image.APPLY_COLOR_PALETTE_FIRST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.APPLY_COLOR_PALETTE_FIRST</span></code></a>: Apply color palette before scaling.</p></li>
<li><p><a class="reference internal" href="#image.BLACK_BACKGROUND" title="image.BLACK_BACKGROUND"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.BLACK_BACKGROUND</span></code></a>: Assume the destination image is black. This speeds up drawing.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">x_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">y_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">y_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">x_size</span></code> to maintain the aspect-ratio.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_size</span></code> may be passed if <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> is not passed to specify the size of the image to draw
and <code class="docutils literal notranslate"><span class="pre">y_scale</span></code> will automatically be determined passed on the input image size. If neither
<code class="docutils literal notranslate"><span class="pre">x_scale</span></code> or <code class="docutils literal notranslate"><span class="pre">x_size</span></code> are specified then <code class="docutils literal notranslate"><span class="pre">x_scale</span></code> internally will be set to be equal to
<code class="docutils literal notranslate"><span class="pre">y_size</span></code> to maintain the aspect-ratio.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.draw_keypoints">
<span class="sig-name descname"><span class="pre">draw_keypoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keypoints</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">size=10</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">thickness=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fill=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.draw_keypoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws the keypoints of a keypoints object on the image. You may also pass a
list of three value tuples containing the (x, y, rotation_angle_in_degrees) to
re-use this method for drawing keypoint glyphs which are a cirle with a line
pointing in a particular direction.</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> is an RGB888 tuple for Grayscale or RGB565 images. Defaults to
white. However, you may also pass the underlying pixel value (0-255) for
grayscale images or a RGB565 value for RGB565 images.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> controls how large the keypoints are.</p>
<p><code class="docutils literal notranslate"><span class="pre">thickness</span></code> controls how thick the line is in pixels.</p>
<p>Pass <code class="docutils literal notranslate"><span class="pre">fill</span></code> set to True to fill the keypoints.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.flood_fill">
<span class="sig-name descname"><span class="pre">flood_fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">seed_threshold=0.05</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">floating_threshold=0.05</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">clear_background=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.flood_fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Flood fills a region of the image starting from location x, y. You may either
pass x, y separately or as a tuple (x, y).</p>
<p><code class="docutils literal notranslate"><span class="pre">seed_threshold</span></code> controls how different any pixel in the fill area may be
from the original starting pixel.</p>
<p><code class="docutils literal notranslate"><span class="pre">floating_threshold</span></code> controls how different any pixel in the fill area may
be from any neighbor pixels.</p>
<p><code class="docutils literal notranslate"><span class="pre">color</span></code> is an RGB888 tuple for Grayscale or RGB565 images. Defaults to
white. However, you may also pass the underlying pixel value (0-255) for
grayscale images or a RGB565 value for RGB565 images.</p>
<p>Pass <code class="docutils literal notranslate"><span class="pre">invert</span></code> as True to re-color everything outside of the flood-fill
connected area.</p>
<p>Pass <code class="docutils literal notranslate"><span class="pre">clear_background</span></code> as True to zero the rest of the pixels that
flood-fill did not re-color.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
evaluated when flood filling.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.mask_rectange">
<span class="sig-name descname"><span class="pre">mask_rectange</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.mask_rectange" title="Permalink to this definition">¶</a></dt>
<dd><p>Zeros a rectangular part of the image. If no arguments are supplied this
method zeros the center of the image.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.mask_circle">
<span class="sig-name descname"><span class="pre">mask_circle</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.mask_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>Zeros a circular part of the image. If no arguments are supplied this
method zeros the center of the image.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.mask_ellipse">
<span class="sig-name descname"><span class="pre">mask_ellipse</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_angle_in_degrees</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.mask_ellipse" title="Permalink to this definition">¶</a></dt>
<dd><p>Zeros an ellipsed shaped part of the image. If no arguments are supplied this
method zeros the center of the image.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.binary">
<span class="sig-name descname"><span class="pre">binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">zero=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">to_bitmap=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">copy=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets all pixels in the image to black or white depending on if the pixel
is inside of a threshold in the threshold list <code class="docutils literal notranslate"><span class="pre">thresholds</span></code> or not.</p>
<p><code class="docutils literal notranslate"><span class="pre">thresholds</span></code> must be a list of tuples <code class="docutils literal notranslate"><span class="pre">[(lo,</span> <span class="pre">hi),</span> <span class="pre">(lo,</span> <span class="pre">hi),</span> <span class="pre">...,</span> <span class="pre">(lo,</span> <span class="pre">hi)]</span></code>
defining the ranges of color you want to track. For grayscale images each tuple
needs to contain two values - a min grayscale value and a max grayscale value.
Only pixel regions that fall between these thresholds will be considered.
For RGB565 images each tuple needs to have six values (l_lo, l_hi, a_lo, a_hi, b_lo, b_hi)
- which are minimums and maximums for the LAB L, A, and B channels respectively.
For easy usage this function will automatically fix swapped min and max values.
Additionally, if a tuple is larger than six values the rest are ignored.
Conversely, if the tuple is too short the rest of the thresholds are assumed
to be at maximum range.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To get the thresholds for the object you want to track just select (click
and drag) on the object you want to track in the IDE frame buffer. The
histogram will then update to just be in that area. Then just write down
where the color distribution starts and falls off in each histogram channel.
These will be your low and high values for <code class="docutils literal notranslate"><span class="pre">thresholds</span></code>. It’s best to
manually determine the thresholds versus using the upper and lower
quartile statistics because they are too tight.</p>
<p>You may also determine color thresholds by going into
<code class="docutils literal notranslate"><span class="pre">Tools-&gt;Machine</span> <span class="pre">Vision-&gt;Threshold</span> <span class="pre">Editor</span></code> in OpenMV IDE and selecting
thresholds from the GUI slider window.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invert</span></code> inverts the thresholding operation such that instead of matching
pixels inside of some known color bounds pixels are matched that are outside
of the known color bounds.</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">zero</span></code> to True to instead zero thresholded pixels and leave pixels
not in the threshold list untouched.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p><code class="docutils literal notranslate"><span class="pre">to_bitmap</span></code> turns the image data into a binary bitmap image where each
pixel is stored in 1 bit. For very small images the new bitmap image may
not fit inside of the original image requiring an out-of-place operation
using <code class="docutils literal notranslate"><span class="pre">copy</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> if True creates a copy of the binarized image on the heap versus
modifying the source image.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Bitmap images are like grayscale images with only two pixels values - 0
and 1. Additionally, bitmap images are packed such that they only store
1 bit per pixel making them very small. The OpenMV image library allows
bitmap images to be used in all places <a class="reference internal" href="omv.sensor.html#sensor.GRAYSCALE" title="sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a> and <a class="reference internal" href="omv.sensor.html#sensor.RGB565" title="sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> images
can be used. However, many operations when applied on bitmap images don’t
make any sense becuase bitmap images only have 2 values. OpenMV recommends
using bitmap images for <code class="docutils literal notranslate"><span class="pre">mask</span></code> values in operations and such as they
fit on the MicroPython heap quite easily. Finally, bitmap image pixel values
0 and 1 are interpreted as black and white when being applied to <a class="reference internal" href="omv.sensor.html#sensor.GRAYSCALE" title="sensor.GRAYSCALE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.GRAYSCALE</span></code></a>
or <a class="reference internal" href="omv.sensor.html#sensor.RGB565" title="sensor.RGB565"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.RGB565</span></code></a> images. The library automatically handles conversion.</p>
</div>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.invert">
<span class="sig-name descname"><span class="pre">invert</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Flips (binary inverts) all pixels values in a binary image very quickly.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.b_and">
<span class="sig-name descname"><span class="pre">b_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.b_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Logically ANDs this image with another image.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.b_nand">
<span class="sig-name descname"><span class="pre">b_nand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.b_nand" title="Permalink to this definition">¶</a></dt>
<dd><p>Logically NANDs this image with another image.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.b_or">
<span class="sig-name descname"><span class="pre">b_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.b_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Logically ORs this image with another image.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.b_nor">
<span class="sig-name descname"><span class="pre">b_nor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.b_nor" title="Permalink to this definition">¶</a></dt>
<dd><p>Logically NORs this image with another image.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.b_xor">
<span class="sig-name descname"><span class="pre">b_xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.b_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Logically XORs this image with another image.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.b_xnor">
<span class="sig-name descname"><span class="pre">b_xnor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.b_xnor" title="Permalink to this definition">¶</a></dt>
<dd><p>Logically XNORs this image with another image.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.erode">
<span class="sig-name descname"><span class="pre">erode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.erode" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes pixels from the edges of segmented areas.</p>
<p>This method works by convolving a kernel of ((size*2)+1)x((size*2)+1) pixels
across the image and zeroing the center pixel of the kernel if the sum of
the neighbour pixels set is not greater than <code class="docutils literal notranslate"><span class="pre">threshold</span></code>.</p>
<p>This method works like the standard erode method if threshold is not set. If
<code class="docutils literal notranslate"><span class="pre">threshold</span></code> is set then you can specify erode to only erode pixels that
have, for example, less than 2 pixels set around them with a threshold of 2.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.dilate">
<span class="sig-name descname"><span class="pre">dilate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.dilate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds pixels to the edges of segmented areas.</p>
<p>This method works by convolving a kernel of ((size*2)+1)x((size*2)+1) pixels
across the image and setting the center pixel of the kernel if the sum of
the neighbour pixels set is greater than <code class="docutils literal notranslate"><span class="pre">threshold</span></code>.</p>
<p>This method works like the standard dilate method if threshold is not set.
If <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is set then you can specify dilate to only dilate pixels
that have, for example, more than 2 pixels set around them with a threshold
of 2.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.open">
<span class="sig-name descname"><span class="pre">open</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs erosion and dilation on an image in order. Please see <a class="reference internal" href="#image.Image.erode" title="image.Image.erode"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.erode()</span></code></a>
and <a class="reference internal" href="#image.Image.dilate" title="image.Image.dilate"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.dilate()</span></code></a> for more information.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs dilation and erosion on an image in order. Please see <a class="reference internal" href="#image.Image.dilate" title="image.Image.dilate"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.dilate()</span></code></a>
and <a class="reference internal" href="#image.Image.erode" title="image.Image.erode"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.erode()</span></code></a> for more information.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.top_hat">
<span class="sig-name descname"><span class="pre">top_hat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.top_hat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the image difference of the image and <a class="reference internal" href="#image.Image.open" title="image.Image.open"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.open()</span></code></a>’ed image.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.black_hat">
<span class="sig-name descname"><span class="pre">black_hat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.black_hat" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the image difference of the image and <a class="reference internal" href="#image.Image.close" title="image.Image.close"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.close()</span></code></a>’ed image.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.awb">
<span class="sig-name descname"><span class="pre">awb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.awb" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs automatic white balance on the image using the gray-world algorithm. This method
operates on RAW Bayer Images so that you can improve image quality before converting
to RGB565 or passing the RAW Bayer Image to an image processing funciton. You may also
call this on a RGB565. This method has no affect on binary/grayscale images.</p>
<p><code class="docutils literal notranslate"><span class="pre">max</span></code> if True uses the white-patch algorithm instead.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.ccm">
<span class="sig-name descname"><span class="pre">ccm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.ccm" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiples the passed (3x3) or (4x3) floating-point color-correction-matrix with the image.</p>
<p>For example, if you pass a 3x3 matrix the method will do this to every pixel the image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">1</span><span class="n">x3</span>         <span class="mi">1</span><span class="n">x4</span>         <span class="mi">4</span><span class="n">x3</span>
<span class="p">[</span><span class="n">R</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Note that the sum of each column in the 3x3 matrix should generally be 1. Weights may either
be positive or negative but, again, should generally sum to 1 per column.</p>
<p>If you pass a 4x3 matrix the method will do this to every pixel the image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">1</span><span class="n">x3</span>         <span class="mi">1</span><span class="n">x4</span>         <span class="mi">4</span><span class="n">x3</span>
<span class="p">[</span><span class="n">R</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                         <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                         <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Where the last row of the 4x3 matrix is an offset per color channel. If you add an offset
you may wish to make the weights sum to less than 1 to account for the offset.</p>
<p>You want to use this method to eliminate systemic cross talk between color channels.
However, this should generally be never.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.gamma">
<span class="sig-name descname"><span class="pre">gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[gamma=1.0,</span> <span class="pre">[contrast=1.0,</span> <span class="pre">[brightness=0.0]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Quickly changes the image gamma, contrast, and brightness. Please use this
method instead of <a class="reference internal" href="#image.Image.mul" title="image.Image.mul"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.mul</span></code></a> or <a class="reference internal" href="#image.Image.div" title="image.Image.div"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.div</span></code></a> which are meant for blending to
adjust pixels values.</p>
<p><code class="docutils literal notranslate"><span class="pre">gamma</span></code> with values greater than 1.0 makes the image darker in a non-linear
manner while less than 1.0 makes the image brighter. The gamma value is applied
to the image by scaling all pixel color channels to be between [0:1) and then
doing a remapping of <code class="docutils literal notranslate"><span class="pre">pow(pixel,</span> <span class="pre">1/gamma)</span></code> on all pixels before scaling back.</p>
<p><code class="docutils literal notranslate"><span class="pre">contrast</span></code> with values greater than 1.0 makes the image brighter in a linear
manner while less than 1.0 makes the image darker. The contrast value is applied
to the image by scaling all pixel color channels to be between [0:1) and then
doing a remapping of <code class="docutils literal notranslate"><span class="pre">pixel</span> <span class="pre">*</span> <span class="pre">contrast</span></code> on all pixels before scaling back.</p>
<p><code class="docutils literal notranslate"><span class="pre">brightness</span></code> with values greater than 0.0 makes the image brighter in a constant
manner while less than 0.0 makes the image darker. The brightness value is applied
to the image by scaling all pixel color channels to be between [0:1) and then
doing a remapping of <code class="docutils literal notranslate"><span class="pre">pixel</span> <span class="pre">+</span> <span class="pre">brightness</span></code> on all pixels before scaling back.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.gamma_corr">
<span class="sig-name descname"><span class="pre">gamma_corr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[gamma=1.0,</span> <span class="pre">[contrast=1.0,</span> <span class="pre">[brightness=0.0]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.gamma_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <a class="reference internal" href="#image.Image.gamma" title="image.Image.gamma"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.gamma</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.negate">
<span class="sig-name descname"><span class="pre">negate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.negate" title="Permalink to this definition">¶</a></dt>
<dd><p>Flips (numerically inverts) all pixels values in an image very quickly. E.g.
for GRAYSCALE images this method changes all pixels from <code class="docutils literal notranslate"><span class="pre">pixel</span></code> to <code class="docutils literal notranslate"><span class="pre">255</span> <span class="pre">-</span> <span class="pre">pixel</span></code>.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hmirror=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">vflip=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">transpose=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces all pixels in the image object with a new image.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be another image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">hmirror</span></code> to True to horizontally mirror the replacing image.</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">vflip</span></code> to True to vertically flip the replacing image.</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">transpose</span></code> to True to flip the image along the diagonal (this changes
the image image width/height if the image is non-square).</p>
<p>If you want to rotate an image by multiples of 90 degrees pass the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>vflip=False, hmirror=False, transpose=False -&gt; 0 degree rotation</p></li>
<li><p>vflip=True,  hmirror=False, transpose=True  -&gt; 90 degree rotation</p></li>
<li><p>vflip=True,  hmirror=True,  transpose=False -&gt; 180 degree rotation</p></li>
<li><p>vflip=False, hmirror=True,  transpose=True  -&gt; 270 degree rotation</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you don’t pass an <code class="docutils literal notranslate"><span class="pre">image</span></code> this method will operate on the underlying
image that you were going to replace by applying the <code class="docutils literal notranslate"><span class="pre">hmirror</span></code>, <code class="docutils literal notranslate"><span class="pre">vflip</span></code>,
and <code class="docutils literal notranslate"><span class="pre">transpose</span></code> options to rotate the image around. E.g. if you want
to do <code class="docutils literal notranslate"><span class="pre">img.replace(img,</span> <span class="pre">etc...)</span></code> you just need to do <code class="docutils literal notranslate"><span class="pre">img.replace(etc..)</span></code>.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified. Note that the mask is applied on the image before hmirror/vflip/transpose
so the mask should be the same width/height of the initial unmodifed image.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.assign">
<span class="sig-name descname"><span class="pre">assign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hmirror=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">vflip=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">transpose=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <a class="reference internal" href="#image.Image.replace" title="image.Image.replace"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.replace</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">hmirror=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">vflip=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">transpose=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <a class="reference internal" href="#image.Image.replace" title="image.Image.replace"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.replace</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an image pixel-wise to this one.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.sub">
<span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">reverse=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts an image pixel-wise to this one.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">reverse</span></code> to True to reverse the subtraction operation from
<code class="docutils literal notranslate"><span class="pre">this_image-image</span></code> to <code class="docutils literal notranslate"><span class="pre">image-this_image</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.mul">
<span class="sig-name descname"><span class="pre">mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies two images pixel-wise with each other.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">invert</span></code> to True to change the multiplication operation from <code class="docutils literal notranslate"><span class="pre">a*b</span></code>
to <code class="docutils literal notranslate"><span class="pre">1/((1/a)*(1/b))</span></code>. In particular, this lightens the image instead of
darkening it (e.g. multiply versus burn operations).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is meant for image blending and cannot multiply the pixels in
the image by a scalar like <code class="docutils literal notranslate"><span class="pre">2</span></code>. Use <a class="reference internal" href="#image.Image.gamma_corr" title="image.Image.gamma_corr"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.gamma_corr</span></code></a> for that.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.div">
<span class="sig-name descname"><span class="pre">div</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mod=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.div" title="Permalink to this definition">¶</a></dt>
<dd><p>Divides this image by another one.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">invert</span></code> to True to change the division direction from <code class="docutils literal notranslate"><span class="pre">a/b</span></code> to
<code class="docutils literal notranslate"><span class="pre">b/a</span></code>.</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">mod</span></code> to True to change the division operation to the modulus operation.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is meant for image blending and cannot divide the pixels in
the image by a scalar like <code class="docutils literal notranslate"><span class="pre">2</span></code>. Use <a class="reference internal" href="#image.Image.gamma_corr" title="image.Image.gamma_corr"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.gamma_corr</span></code></a> for that.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.min">
<span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the minimum image of two images pixel-wise.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.max">
<span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum image of two images pixel-wise.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.difference">
<span class="sig-name descname"><span class="pre">difference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the absolute difference image between two images (e.g. ||a-b||).</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.blend">
<span class="sig-name descname"><span class="pre">blend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">alpha=128</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.blend" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha blends two images with each other.</p>
<p><code class="docutils literal notranslate"><span class="pre">image</span></code> can either be an image object, a path to an uncompressed image
file (bmp/pgm/ppm), or a scalar value. If a scalar value the value can
either be an RGB888 tuple or the underlying pixel value (e.g. an 8-bit grayscale
for grayscale images or a RGB565 value for RGB images).</p>
<p><code class="docutils literal notranslate"><span class="pre">alpha</span></code> controls how much of the other image to blend into this image.
<code class="docutils literal notranslate"><span class="pre">alpha</span></code> should be an integer value between 0 and 256. A value closer to
zero blends more of the other image into this image and a value closer to
256 does the opposite.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.histeq">
<span class="sig-name descname"><span class="pre">histeq</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">adaptive=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">clip_limit=-1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.histeq" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the histogram equalization algorithm on the image. Histogram
equalization normalizes the contrast and brightness in the image.</p>
<p>If you pass <code class="docutils literal notranslate"><span class="pre">adaptive</span></code> as True then an adaptive histogram equalization
method will be run on the image instead which as generally better results
than non-adaptive histogram qualization but a longer run time.</p>
<p><code class="docutils literal notranslate"><span class="pre">clip_limit</span></code> provides a way to limit the contrast of the adaptive histogram
qualization. Use a small value for this, like 10, to produce good histogram
equalized contrast limited images.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.mean">
<span class="sig-name descname"><span class="pre">mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">size,</span> <span class="pre">[threshold=False,</span> <span class="pre">[offset=0,</span> <span class="pre">[invert=False,</span> <span class="pre">[mask=None]]]]]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard mean blurring filter using a box filter.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> is the kernel size. Use 1 (3x3 kernel), 2 (5x5 kernel), etc.</p>
<p>If you’d like to adaptive threshold the image on the output of the filter
you can pass <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> which will enable adaptive thresholding of the
image which sets pixels to one or zero based on a pixel’s brightness in relation
to the brightness of the kernel of pixels around them. A negative <code class="docutils literal notranslate"><span class="pre">offset</span></code>
value sets more pixels to 1 as you make it more negative while a positive
value only sets the sharpest contrast changes to 1. Set <code class="docutils literal notranslate"><span class="pre">invert</span></code> to invert
the binary image resulting output.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.median">
<span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">percentile=0.5</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the median filter on the image. The median filter is the best filter
for smoothing surfaces while preserving edges but it is very slow.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> is the kernel size. Use 1 (3x3 kernel), 2 (5x5 kernel), etc.</p>
<p><code class="docutils literal notranslate"><span class="pre">percentile</span></code> controls the percentile of the value used in the kernel. By
default each pixel is replaced with the 50th percentile (center) of its
neighbors. You can set this to 0 for a min filter, 0.25 for a lower quartile
filter, 0.75 for an upper quartile filter, and 1.0 for a max filter.</p>
<p>If you’d like to adaptive threshold the image on the output of the filter
you can pass <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> which will enable adaptive thresholding of the
image which sets pixels to one or zero based on a pixel’s brightness in relation
to the brightness of the kernel of pixels around them. A negative <code class="docutils literal notranslate"><span class="pre">offset</span></code>
value sets more pixels to 1 as you make it more negative while a positive
value only sets the sharpest contrast changes to 1. Set <code class="docutils literal notranslate"><span class="pre">invert</span></code> to invert
the binary image resulting output.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.mode">
<span class="sig-name descname"><span class="pre">mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">size,</span> <span class="pre">[threshold=False,</span> <span class="pre">[offset=0,</span> <span class="pre">[invert=False,</span> <span class="pre">[mask=None]]]]]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the mode filter on the image by replacing each pixel with the mode of
their neighbors. This method works great on grayscale images. However, on
RGB images it creates a lot of artifacts on edges because of the non-linear
nature of the operation.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> is the kernel size. Use 1 (3x3 kernel), 2 (5x5 kernel), etc.</p>
<p>If you’d like to adaptive threshold the image on the output of the filter
you can pass <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> which will enable adaptive thresholding of the
image which sets pixels to one or zero based on a pixel’s brightness in relation
to the brightness of the kernel of pixels around them. A negative <code class="docutils literal notranslate"><span class="pre">offset</span></code>
value sets more pixels to 1 as you make it more negative while a positive
value only sets the sharpest contrast changes to 1. Set <code class="docutils literal notranslate"><span class="pre">invert</span></code> to invert
the binary image resulting output.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.midpoint">
<span class="sig-name descname"><span class="pre">midpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">bias=0.5</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.midpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the midpoint filter on the image. This filter finds the midpoint
((max-min)/2) of each pixel neighborhood in the image.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> is the kernel size. Use 1 (3x3 kernel), 2 (5x5 kernel), etc.</p>
<p><code class="docutils literal notranslate"><span class="pre">bias</span></code> controls the min/max mixing. 0 for min filtering only, 1.0 for max
filtering only. By using the <code class="docutils literal notranslate"><span class="pre">bias</span></code> you can min/max filter the image.</p>
<p>If you’d like to adaptive threshold the image on the output of the filter
you can pass <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> which will enable adaptive thresholding of the
image which sets pixels to one or zero based on a pixel’s brightness in relation
to the brightness of the kernel of pixels around them. A negative <code class="docutils literal notranslate"><span class="pre">offset</span></code>
value sets more pixels to 1 as you make it more negative while a positive
value only sets the sharpest contrast changes to 1. Set <code class="docutils literal notranslate"><span class="pre">invert</span></code> to invert
the binary image resulting output.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.morph">
<span class="sig-name descname"><span class="pre">morph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mul</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">add=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.morph" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolves the image by a filter kernel. This allows you to do general purpose
convolutions on an image.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> controls the size of the kernel which must be
((size*2)+1)x((size*2)+1) elements big.</p>
<p><code class="docutils literal notranslate"><span class="pre">kernel</span></code> is the kernel to convolve the image by. It can either be a tuple
or a list of integer values.</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> is number to multiply the convolution pixel results by. When not set
it defaults to a value that will prevent scaling in the convolution output.</p>
<p><code class="docutils literal notranslate"><span class="pre">add</span></code> is a value to add to each convolution pixel result.</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> basically allows you to do a global contrast adjustment and <code class="docutils literal notranslate"><span class="pre">add</span></code>
allows you to do a global brightness adjustment. Pixels that go outside of
the image mins and maxes for color channels will be clipped.</p>
<p>If you’d like to adaptive threshold the image on the output of the filter
you can pass <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> which will enable adaptive thresholding of the
image which sets pixels to one or zero based on a pixel’s brightness in relation
to the brightness of the kernel of pixels around them. A negative <code class="docutils literal notranslate"><span class="pre">offset</span></code>
value sets more pixels to 1 as you make it more negative while a positive
value only sets the sharpest contrast changes to 1. Set <code class="docutils literal notranslate"><span class="pre">invert</span></code> to invert
the binary image resulting output.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.gaussian">
<span class="sig-name descname"><span class="pre">gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">unsharp=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mul</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">add=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolves the image by a smoothing guassian kernel.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> is the kernel size. Use 1 (3x3 kernel), 2 (5x5 kernel), etc.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">unsharp</span></code> is set to the True then instead of doing just a guassian
filtering operation this method will perform an unsharp mask operation which
improves image sharpness on edges.</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> is number to multiply the convolution pixel results by. When not set
it defaults to a value that will prevent scaling in the convolution output.</p>
<p><code class="docutils literal notranslate"><span class="pre">add</span></code> is a value to add to each convolution pixel result.</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> basically allows you to do a global contrast adjustment and <code class="docutils literal notranslate"><span class="pre">add</span></code>
allows you to do a global brightness adjustment. Pixels that go outside of
the image mins and maxes for color channels will be clipped.</p>
<p>If you’d like to adaptive threshold the image on the output of the filter
you can pass <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> which will enable adaptive thresholding of the
image which sets pixels to one or zero based on a pixel’s brightness in relation
to the brightness of the kernel of pixels around them. A negative <code class="docutils literal notranslate"><span class="pre">offset</span></code>
value sets more pixels to 1 as you make it more negative while a positive
value only sets the sharpest contrast changes to 1. Set <code class="docutils literal notranslate"><span class="pre">invert</span></code> to invert
the binary image resulting output.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.laplacian">
<span class="sig-name descname"><span class="pre">laplacian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">sharpen=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mul</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">add=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.laplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolves the image by a edge detecting laplacian kernel.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> is the kernel size. Use 1 (3x3 kernel), 2 (5x5 kernel), etc.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sharpen</span></code> is set to the True then instead of just outputting an
unthresholded edge detection image this method will instead sharpen the
image. Increase the kernel size then to increase the image sharpness.</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> is number to multiply the convolution pixel results by. When not set
it defaults to a value that will prevent scaling in the convolution output.</p>
<p><code class="docutils literal notranslate"><span class="pre">add</span></code> is a value to add to each convolution pixel result.</p>
<p><code class="docutils literal notranslate"><span class="pre">mul</span></code> basically allows you to do a global contrast adjustment and <code class="docutils literal notranslate"><span class="pre">add</span></code>
allows you to do a global brightness adjustment. Pixels that go outside of
the image mins and maxes for color channels will be clipped.</p>
<p>If you’d like to adaptive threshold the image on the output of the filter
you can pass <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> which will enable adaptive thresholding of the
image which sets pixels to one or zero based on a pixel’s brightness in relation
to the brightness of the kernel of pixels around them. A negative <code class="docutils literal notranslate"><span class="pre">offset</span></code>
value sets more pixels to 1 as you make it more negative while a positive
value only sets the sharpest contrast changes to 1. Set <code class="docutils literal notranslate"><span class="pre">invert</span></code> to invert
the binary image resulting output.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.bilateral">
<span class="sig-name descname"><span class="pre">bilateral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">color_sigma=0.1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">space_sigma=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">mask=None</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.bilateral" title="Permalink to this definition">¶</a></dt>
<dd><p>Convolves the image by a bilateral filter. The bilateral filter smooths the
image while keeping edges in the image.</p>
<p><code class="docutils literal notranslate"><span class="pre">size</span></code> is the kernel size. Use 1 (3x3 kernel), 2 (5x5 kernel), etc.</p>
<p><code class="docutils literal notranslate"><span class="pre">color_sigma</span></code> controls how closely colors are matched using the bilateral
filter. Increase this to increase color blurring.</p>
<p><code class="docutils literal notranslate"><span class="pre">space_sigma</span></code> controls how closely pixels space-wise are blurred with
each other. Increase this to increase pixel blurring.</p>
<p>If you’d like to adaptive threshold the image on the output of the filter
you can pass <code class="docutils literal notranslate"><span class="pre">threshold=True</span></code> which will enable adaptive thresholding of the
image which sets pixels to one or zero based on a pixel’s brightness in relation
to the brightness of the kernel of pixels around them. A negative <code class="docutils literal notranslate"><span class="pre">offset</span></code>
value sets more pixels to 1 as you make it more negative while a positive
value only sets the sharpest contrast changes to 1. Set <code class="docutils literal notranslate"><span class="pre">invert</span></code> to invert
the binary image resulting output.</p>
<p><code class="docutils literal notranslate"><span class="pre">mask</span></code> is another image to use as a pixel level mask for the operation.
The mask should be an image with just black or white pixels and should be the
same size as the image being operated on. Only pixels set in the mask are
modified.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.linpolar">
<span class="sig-name descname"><span class="pre">linpolar</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">reverse=False</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.linpolar" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-project’s and image from cartessian coordinates to linear polar coordinates.</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">reverse=True</span></code> to re-project in the opposite direction.</p>
<p>Linear polar re-projection turns rotation of an image into x-translation.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.logpolar">
<span class="sig-name descname"><span class="pre">logpolar</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">reverse=False</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.logpolar" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-project’s and image from cartessian coordinates to log polar coordinates.</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">reverse=True</span></code> to re-project in the opposite direction.</p>
<p>Log polar re-projection turns rotation of an image into x-translation
and scaling/zooming into y-translation.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.lens_corr">
<span class="sig-name descname"><span class="pre">lens_corr</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">strength=1.8</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">zoom=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_corr=0.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_corr=0.0</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.lens_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs lens correction to un-fisheye the image due to the lens distortion.</p>
<p><code class="docutils literal notranslate"><span class="pre">strength</span></code> is a float defining how much to un-fisheye the image. Try 1.8
out by default and then increase or decrease from there until the image
looks good.</p>
<p><code class="docutils literal notranslate"><span class="pre">zoom</span></code> is the amount to zoom in on the image by. 1.0 by default.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_corr</span></code> floating point pixel offset from center. Can be negative or positive.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_corr</span></code> floating point pixel offset from center. Can be negative or positive.</p>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.img.rotation_corr">
<span class="sig-prename descclassname"><span class="pre">img.</span></span><span class="sig-name descname"><span class="pre">rotation_corr</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">x_rotation=0.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_rotation=0.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">z_rotation=0.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_translation=0.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_translation=0.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">zoom=1.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fov=60.0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">corners</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.img.rotation_corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Corrects perspective issues in the image by doing a 3D rotation of the frame buffer.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_rotation</span></code> is the number of degrees to rotation the image in the frame buffer
around the x axis (i.e. this spins the image up and down).</p>
<p><code class="docutils literal notranslate"><span class="pre">y_rotation</span></code> is the number of degrees to rotation the image in the frame buffer
around the y axis (i.e. this spins the image left and right).</p>
<p><code class="docutils literal notranslate"><span class="pre">z_rotation</span></code> is the number of degrees to rotation the image in the frame buffer
around the z axis (i.e. this spins the image in place).</p>
<p><code class="docutils literal notranslate"><span class="pre">x_translation</span></code> is the number of units to move the image to the left or right
after rotation. Because this translation is applied in 3D space the units aren’t pixels…</p>
<p><code class="docutils literal notranslate"><span class="pre">y_translation</span></code> is the number of units to move the image to the up or down
after rotation. Because this translation is applied in 3D space the units aren’t pixels…</p>
<p><code class="docutils literal notranslate"><span class="pre">zoom</span></code> is the amount to zoom in on the image by. 1.0 by default.</p>
<p><code class="docutils literal notranslate"><span class="pre">fov</span></code> is the field-of-view to use internally when doing 2D-&gt;3D projection before
rotating the image in 3D space. As this value approaches 0 the image is placed at infinity away
from the viewport. As this value approaches 180 the image is placed within the viewport. Typically,
you should not change this value but you can modify it to change the 2D-&gt;3D mapping effect.</p>
<p><code class="docutils literal notranslate"><span class="pre">corners</span></code> is a list of four (x,y) tuples representing four corners used to create a 4-point
correspondence homography that will map the first corner to (0, 0), the second corner to
(image_width-1, 0), the third corner to (image_width-1, image_height-1), and the fourth corner
to (0, image_height-1). The 3D rotation is then applied after the image is re-mapped. This
argument lets you use <a class="reference internal" href="#image.Image.img.rotation_corr" title="image.Image.img.rotation_corr"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">rotation_corr</span></code></a> to do things like birds-eye-view transforms. E.g:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">top_tilt</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># if the difference between top/bottom_tilt become to large this method will stop working</span>
<span class="n">bottom_tilt</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">tilt</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">width</span><span class="p">()</span><span class="o">-</span><span class="n">tilt</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">width</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">bottom_tilt</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">height</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">bottom_tilt</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">height</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

<span class="n">img</span><span class="o">.</span><span class="n">rotation_corr</span><span class="p">(</span><span class="n">corners</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns the image object so you can call another method using <code class="docutils literal notranslate"><span class="pre">.</span></code> notation.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.get_histogram">
<span class="sig-name descname"><span class="pre">get_histogram</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">l_bins</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">a_bins</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">b_bins</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">difference</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.get_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the normalized histogram on all color channels for an <code class="docutils literal notranslate"><span class="pre">roi</span></code> and
returns a <a class="reference internal" href="#image.histogram" title="image.histogram"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.histogram</span></code></a> object. Please see the <a class="reference internal" href="#image.histogram" title="image.histogram"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.histogram</span></code></a> object for more
information. You can also invoke this method by using <code class="docutils literal notranslate"><span class="pre">Image.get_hist()</span></code> or
<code class="docutils literal notranslate"><span class="pre">Image.histogram()</span></code>. If you pass a list of <code class="docutils literal notranslate"><span class="pre">thresholds</span></code> then the histogram
information will only be computed from pixels within the threshold list.</p>
<p><code class="docutils literal notranslate"><span class="pre">thresholds</span></code> must be a list of tuples
<code class="docutils literal notranslate"><span class="pre">[(lo,</span> <span class="pre">hi),</span> <span class="pre">(lo,</span> <span class="pre">hi),</span> <span class="pre">...,</span> <span class="pre">(lo,</span> <span class="pre">hi)]</span></code> defining the ranges of color you
want to track. For
grayscale images each tuple needs to contain two values - a min grayscale
value and a max grayscale value. Only pixel regions that fall between these
thresholds will be considered. For RGB565 images each tuple needs to have
six values (l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - which are minimums and
maximums for the LAB L, A, and B channels respectively. For easy usage this
function will automatically fix swapped min and max values. Additionally,
if a tuple is larger than six values the rest are ignored. Conversely, if the
tuple is too short the rest of the thresholds are assumed to be at maximum
range.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To get the thresholds for the object you want to track just select (click
and drag) on the object you want to track in the IDE frame buffer. The
histogram will then update to just be in that area. Then just write down
where the color distribution starts and falls off in each histogram channel.
These will be your low and high values for <code class="docutils literal notranslate"><span class="pre">thresholds</span></code>. It’s best to
manually determine the thresholds versus using the upper and lower
quartile statistics because they are too tight.</p>
<p>You may also determine color thresholds by going into
<code class="docutils literal notranslate"><span class="pre">Tools-&gt;Machine</span> <span class="pre">Vision-&gt;Threshold</span> <span class="pre">Editor</span></code> in OpenMV IDE and selecting
thresholds from the GUI slider window.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invert</span></code> inverts the thresholding operation such that instead of matching
pixels inside of some known color bounds pixels are matched that are outside
of the known color bounds.</p>
<p>Unless you need to do something advanced with color statistics just use the
<a class="reference internal" href="#image.Image.get_statistics" title="image.Image.get_statistics"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.get_statistics()</span></code></a> method instead of this method for looking at pixel
areas in an image.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">bins</span></code> and others are the number of bins to use for the histogram
channels. For grayscale images use <code class="docutils literal notranslate"><span class="pre">bins</span></code> and for RGB565 images use
the others for each channel. The bin counts must be greater than 2 for each
channel. Additionally, it makes no sense to set the bin count larger than
the number of unique pixel values for each channel. By default, the historgram
will have the maximum number of bins per channel.</p>
<p><code class="docutils literal notranslate"><span class="pre">difference</span></code> may be set to an image object to cause this method to operate
on the difference image between the current image and the <code class="docutils literal notranslate"><span class="pre">difference</span></code> image
object. This saves having to use a separate buffer.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.get_statistics">
<span class="sig-name descname"><span class="pre">get_statistics</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">l_bins</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">a_bins</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">b_bins</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">difference</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.get_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the mean, median, mode, standard deviation, min, max, lower
quartile, and upper quartile for all color channels for an <code class="docutils literal notranslate"><span class="pre">roi</span></code> and
returns a <a class="reference internal" href="#image.statistics" title="image.statistics"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.statistics</span></code></a> object. Please see the <a class="reference internal" href="#image.statistics" title="image.statistics"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.statistics</span></code></a>
object for more information. You can also invoke this method by using
<code class="docutils literal notranslate"><span class="pre">Image.get_stats()</span></code> or <code class="docutils literal notranslate"><span class="pre">Image.statistics()</span></code>. If you pass a list of
<code class="docutils literal notranslate"><span class="pre">thresholds</span></code> then the histogram information will only be computed from
pixels within the threshold list.</p>
<p><code class="docutils literal notranslate"><span class="pre">thresholds</span></code> must be a list of tuples
<code class="docutils literal notranslate"><span class="pre">[(lo,</span> <span class="pre">hi),</span> <span class="pre">(lo,</span> <span class="pre">hi),</span> <span class="pre">...,</span> <span class="pre">(lo,</span> <span class="pre">hi)]</span></code> defining the ranges of color you
want to track. For
grayscale images each tuple needs to contain two values - a min grayscale
value and a max grayscale value. Only pixel regions that fall between these
thresholds will be considered. For RGB565 images each tuple needs to have
six values (l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - which are minimums and
maximums for the LAB L, A, and B channels respectively. For easy usage this
function will automatically fix swapped min and max values. Additionally,
if a tuple is larger than six values the rest are ignored. Conversely, if the
tuple is too short the rest of the thresholds are assumed to be at maximum
range.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To get the thresholds for the object you want to track just select (click
and drag) on the object you want to track in the IDE frame buffer. The
histogram will then update to just be in that area. Then just write down
where the color distribution starts and falls off in each histogram channel.
These will be your low and high values for <code class="docutils literal notranslate"><span class="pre">thresholds</span></code>. It’s best to
manually determine the thresholds versus using the upper and lower
quartile statistics because they are too tight.</p>
<p>You may also determine color thresholds by going into
<code class="docutils literal notranslate"><span class="pre">Tools-&gt;Machine</span> <span class="pre">Vision-&gt;Threshold</span> <span class="pre">Editor</span></code> in OpenMV IDE and selecting
thresholds from the GUI slider window.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invert</span></code> inverts the thresholding operation such that instead of matching
pixels inside of some known color bounds pixels are matched that are outside
of the known color bounds.</p>
<p>You’ll want to use this method any time you need to get information about
the values of an area of pixels in an image. For example, after if you’re
trying to detect motion using frame differencing you’ll want to use this
method to determine a change in the color channels of the image to trigger
your motion detection threshold.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">bins</span></code> and others are the number of bins to use for the histogram
channels. For grayscale images use <code class="docutils literal notranslate"><span class="pre">bins</span></code> and for RGB565 images use
the others for each channel. The bin counts must be greater than 2 for each
channel. Additionally, it makes no sense to set the bin count larger than
the number of unique pixel values for each channel. By default, the historgram
will have the maximum number of bins per channel.</p>
<p><code class="docutils literal notranslate"><span class="pre">difference</span></code> may be set to an image object to cause this method to operate
on the difference image between the current image and the <code class="docutils literal notranslate"><span class="pre">difference</span></code> image
object. This saves having to use a separate buffer.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.get_regression">
<span class="sig-name descname"><span class="pre">get_regression</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_stride=2</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_stride=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">area_threshold=10</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pixels_threshold=10</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">robust=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.get_regression" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a linear regression on all the thresholded pixels in the image. The
linear regression is computed using least-squares normally which is fast but
cannot handle any outliers. If <code class="docutils literal notranslate"><span class="pre">robust</span></code> is True then the Theil–Sen linear
regression is used instead which computes the median of all slopes between
all thresholded pixels in the image. This is an N^2 operation which may drops
your FPS down to below 5 even on an 80x60 image if too many pixels are set
after thresholding. However, as long as the number of pixels set after
thresholding remains low the linear regression will be valid even in the case
of up to 30% of the thresholded pixels being outliers (e.g. it’s robust).</p>
<p>This method returns a <a class="reference internal" href="#image.line" title="image.line"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.line</span></code></a> object. See this blog post on how to use the
line object easily: <a class="reference external" href="https://openmv.io/blogs/news/linear-regression-line-following">https://openmv.io/blogs/news/linear-regression-line-following</a></p>
<p><code class="docutils literal notranslate"><span class="pre">thresholds</span></code> must be a list of tuples
<code class="docutils literal notranslate"><span class="pre">[(lo,</span> <span class="pre">hi),</span> <span class="pre">(lo,</span> <span class="pre">hi),</span> <span class="pre">...,</span> <span class="pre">(lo,</span> <span class="pre">hi)]</span></code> defining the ranges of color you
want to track. For
grayscale images each tuple needs to contain two values - a min grayscale
value and a max grayscale value. Only pixel regions that fall between these
thresholds will be considered. For RGB565 images each tuple needs to have
six values (l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - which are minimums and
maximums for the LAB L, A, and B channels respectively. For easy usage this
function will automatically fix swapped min and max values. Additionally,
if a tuple is larger than six values the rest are ignored. Conversely, if the
tuple is too short the rest of the thresholds are assumed to be at maximum
range.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To get the thresholds for the object you want to track just select (click
and drag) on the object you want to track in the IDE frame buffer. The
histogram will then update to just be in that area. Then just write down
where the color distribution starts and falls off in each histogram channel.
These will be your low and high values for <code class="docutils literal notranslate"><span class="pre">thresholds</span></code>. It’s best to
manually determine the thresholds versus using the upper and lower
quartile statistics because they are too tight.</p>
<p>You may also determine color thresholds by going into
<code class="docutils literal notranslate"><span class="pre">Tools-&gt;Machine</span> <span class="pre">Vision-&gt;Threshold</span> <span class="pre">Editor</span></code> in OpenMV IDE and selecting
thresholds from the GUI slider window.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invert</span></code> inverts the thresholding operation such that instead of matching
pixels inside of some known color bounds pixels are matched that are outside
of the known color bounds.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_stride</span></code> is the number of x pixels to skip over when evaluating the image.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_stride</span></code> is the number of y pixels to skip over when evaluating the image.</p>
<p>If the regression’s bounding box area is less than <code class="docutils literal notranslate"><span class="pre">area_threshold</span></code> then None is returned.</p>
<p>If the regression’s pixel count is less than <code class="docutils literal notranslate"><span class="pre">pixels_threshold</span></code> then None is returned.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_blobs">
<span class="sig-name descname"><span class="pre">find_blobs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">invert=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_stride=2</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_stride=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">area_threshold=10</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">pixels_threshold=10</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">merge=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">margin=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold_cb=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">merge_cb=None</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_hist_bins_max=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_hist_bins_max=0</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_blobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all blobs (connected pixel regions that pass a threshold test) in the
image and returns a list of <a class="reference internal" href="#image.blob" title="image.blob"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.blob</span></code></a> objects which describe each blob.
Please see the <a class="reference internal" href="#image.blob" title="image.blob"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.blob</span></code></a> object more more information.</p>
<p><code class="docutils literal notranslate"><span class="pre">thresholds</span></code> must be a list of tuples
<code class="docutils literal notranslate"><span class="pre">[(lo,</span> <span class="pre">hi),</span> <span class="pre">(lo,</span> <span class="pre">hi),</span> <span class="pre">...,</span> <span class="pre">(lo,</span> <span class="pre">hi)]</span></code> defining the ranges of color you
want to track. You may pass up to 32 threshold tuples in one call. For
grayscale images each tuple needs to contain two values - a min grayscale
value and a max grayscale value. Only pixel regions that fall between these
thresholds will be considered. For RGB565 images each tuple needs to have
six values (l_lo, l_hi, a_lo, a_hi, b_lo, b_hi) - which are minimums and
maximums for the LAB L, A, and B channels respectively. For easy usage this
function will automatically fix swapped min and max values. Additionally,
if a tuple is larger than six values the rest are ignored. Conversely, if the
tuple is too short the rest of the thresholds are assumed to be at maximum
range.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To get the thresholds for the object you want to track just select (click
and drag) on the object you want to track in the IDE frame buffer. The
histogram will then update to just be in that area. Then just write down
where the color distribution starts and falls off in each histogram channel.
These will be your low and high values for <code class="docutils literal notranslate"><span class="pre">thresholds</span></code>. It’s best to
manually determine the thresholds versus using the upper and lower
quartile statistics because they are too tight.</p>
<p>You may also determine color thresholds by going into
<code class="docutils literal notranslate"><span class="pre">Tools-&gt;Machine</span> <span class="pre">Vision-&gt;Threshold</span> <span class="pre">Editor</span></code> in OpenMV IDE and selecting
thresholds from the GUI slider window.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">invert</span></code> inverts the thresholding operation such that instead of matching
pixels inside of some known color bounds pixels are matched that are outside
of the known color bounds.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_stride</span></code> is the number of x pixels to skip when searching for a blob.
Once a blob is found the line fill algorithm will be pixel accurate.
Increase <code class="docutils literal notranslate"><span class="pre">x_stride</span></code> to speed up finding blobs if blobs are known to be large.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_stride</span></code> is the number of y pixels to skip when searching for a blob.
Once a blob is found the line fill algorithm will be pixel accurate.
Increase <code class="docutils literal notranslate"><span class="pre">y_stride</span></code> to speed up finding blobs if blobs are known to be large.</p>
<p>If a blob’s bounding box area is less than <code class="docutils literal notranslate"><span class="pre">area_threshold</span></code> it is filtered
out.</p>
<p>If a blob’s pixel count is less than <code class="docutils literal notranslate"><span class="pre">pixels_threshold</span></code> it is filtered out.</p>
<p><code class="docutils literal notranslate"><span class="pre">merge</span></code> if True merges all not filtered out blobs whos bounding
rectangles intersect each other. <code class="docutils literal notranslate"><span class="pre">margin</span></code> can be used to increase or
decrease the size of the bounding rectangles for blobs during the
intersection test. For example, with a margin of 1 blobs whos bounding
rectangles are 1 pixel away from each other will be merged.</p>
<p>Merging blobs allows you to implement color code tracking. Each blob object
has a <code class="docutils literal notranslate"><span class="pre">code</span></code> value which is a bit vector made up of 1s for each color
threshold. For example, if you pass <a class="reference internal" href="#image.Image.find_blobs" title="image.Image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_blobs</span></code></a> two color
thresholds then the first threshold has a code of 1 and the second 2 (a
third threshold would be 4 and a fourth would be 8 and so on). Merged blobs
logically OR all their codes together so that you know what colors produced
them. This allows you to then track two colors if you get a blob object
back with two colors then you know it might be a color code.</p>
<p>You might also want to merge blobs if you are using tight color bounds which
do not fully track all the pixels of an object you are trying to follow.</p>
<p>Finally, if you want to merge blobs, but, don’t want two color thresholds to
be merged then just call <a class="reference internal" href="#image.Image.find_blobs" title="image.Image.find_blobs"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_blobs</span></code></a> twice with separate thresholds
so that blobs aren’t merged.</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold_cb</span></code> may be set to the function to call on every blob after its
been thresholded to filter it from the list of blobs to be merged. The call
back function will receive one argument - the blob object to be filtered.
The call back then must return True to keep the blob and False to filter it.</p>
<p><code class="docutils literal notranslate"><span class="pre">merge_cb</span></code> may be set to the function to call on every two blobs about to
be merged to prevent or allow the merge. The call back function will receive
two arguments - the two blob objects to be merged. The call back then must
return True to merge the blobs or False to prevent merging the blobs.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_hist_bins_max</span></code> if set to non-zero populates a histogram buffer in each
blob object with an x_histogram projection of all columns in the object. This
value then sets the number of bins for that projection.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_hist_bins_max</span></code> if set to non-zero populates a histogram buffer in each
blob object with an y_histogram projection of all rows in the object. This
value then sets the number of bins for that projection.</p>
<p>Not supported on compressed images or bayer images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_lines">
<span class="sig-name descname"><span class="pre">find_lines</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_stride=2</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_stride=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=1000</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">theta_margin=25</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">rho_margin=25</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all infinite lines in the image using the hough transform. Returns a list
of <a class="reference internal" href="#image.line" title="image.line"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.line</span></code></a> objects.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_stride</span></code> is the number of x pixels to skip when doing the hough transform.
Only increase this if lines you are searching for are large and bulky.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_stride</span></code> is the number of y pixels to skip when doing the hough transform.
Only increase this if lines you are searching for are large and bulky.</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> controls what lines are detected from the hough transform. Only
lines with a magnitude greater than or equal to <code class="docutils literal notranslate"><span class="pre">threshold</span></code> are returned. The
right value of <code class="docutils literal notranslate"><span class="pre">threshold</span></code> for your application is image dependent. Note that
the magnitude of a line is the sum of all sobel filter magnitudes of pixels
that make up that line.</p>
<p><code class="docutils literal notranslate"><span class="pre">theta_margin</span></code> controls the merging of detected lines. Lines which are
<code class="docutils literal notranslate"><span class="pre">theta_margin</span></code> degrees apart and <code class="docutils literal notranslate"><span class="pre">rho_margin</span></code> rho apart are merged.</p>
<p><code class="docutils literal notranslate"><span class="pre">rho_margin</span></code> controls the merging of detected lines. Lines which are
<code class="docutils literal notranslate"><span class="pre">theta_margin</span></code> degrees apart and <code class="docutils literal notranslate"><span class="pre">rho_margin</span></code> rho apart are merged.</p>
<p>This method working by running the sobel filter over the image and taking
the magnitude and gradient responses from the sobel filter to feed a hough
transform. It does not require any preprocessing on the image first. However,
my cleaning up the image using filtering you may get more stable results.</p>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_line_segments">
<span class="sig-name descname"><span class="pre">find_line_segments</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">merge_distance=0</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">max_theta_difference=15</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_line_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds line segments in the image using the hough transform. Returns a list
of <a class="reference internal" href="#image.line" title="image.line"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.line</span></code></a> objects .</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">merge_distance</span></code> specifies the maximum number of pixels two line segements
can be seperated by each other (at any point on one line) to be merged.</p>
<p><code class="docutils literal notranslate"><span class="pre">max_theta_difference</span></code> is the maximum theta difference in degrees two line
segements that are <code class="docutils literal notranslate"><span class="pre">merge_distance</span></code> apart to be merged.</p>
<p>This method uses the LSD library (also used by OpenCV) to find line segements
in the image. It’s somewhat slow but very accurate and lines don’t jump around.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_circles">
<span class="sig-name descname"><span class="pre">find_circles</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_stride=2</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_stride=1</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=2000</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x_margin=10</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">y_margin=10</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">r_margin=10</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">r_min=2</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">r_max</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">r_step=2</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_circles" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds circles in the image using the hough transform. Returns a list of
<a class="reference internal" href="#image.circle" title="image.circle"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.circle</span></code></a> objects.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_stride</span></code> is the number of x pixels to skip when doing the hough transform.
Only increase this if circles you are searching for are large and bulky.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_stride</span></code> is the number of y pixels to skip when doing the hough transform.
Only increase this if circles you are searching for are large and bulky.</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> controls what circles are detected from the hough transform. Only
circles with a magnitude greater than or equal to <code class="docutils literal notranslate"><span class="pre">threshold</span></code> are returned. The
right value of <code class="docutils literal notranslate"><span class="pre">threshold</span></code> for your application is image dependent. Note that
the magnitude of a circle is the sum of all sobel filter magnitudes of pixels
that make up that circle.</p>
<p><code class="docutils literal notranslate"><span class="pre">x_margin</span></code> controls the merging of detected circles. Circles which are
<code class="docutils literal notranslate"><span class="pre">x_margin</span></code>, <code class="docutils literal notranslate"><span class="pre">y_margin</span></code>, and <code class="docutils literal notranslate"><span class="pre">r_margin</span></code> pixels apart are merged.</p>
<p><code class="docutils literal notranslate"><span class="pre">y_margin</span></code> controls the merging of detected circles. Circles which are
<code class="docutils literal notranslate"><span class="pre">x_margin</span></code>, <code class="docutils literal notranslate"><span class="pre">y_margin</span></code>, and <code class="docutils literal notranslate"><span class="pre">r_margin</span></code> pixels apart are merged.</p>
<p><code class="docutils literal notranslate"><span class="pre">r_margin</span></code> controls the merging of detected circles. Circles which are
<code class="docutils literal notranslate"><span class="pre">x_margin</span></code>, <code class="docutils literal notranslate"><span class="pre">y_margin</span></code>, and <code class="docutils literal notranslate"><span class="pre">r_margin</span></code> pixels apart are merged.</p>
<p><code class="docutils literal notranslate"><span class="pre">r_min</span></code> controls the minimum circle radius detected. Increase this to speed
up the algorithm. Defaults to 2.</p>
<p><code class="docutils literal notranslate"><span class="pre">r_max</span></code> controls the maximum circle radius detected. Decrease this to speed
up the algorithm. Defaults to min(roi.w/2, roi.h/2).</p>
<p><code class="docutils literal notranslate"><span class="pre">r_step</span></code> controls how to step the radius detection by. Defaults to 2.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_rects">
<span class="sig-name descname"><span class="pre">find_rects</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">roi=Auto</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=10000</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_rects" title="Permalink to this definition">¶</a></dt>
<dd><p>Find rectangles in the image using the same quad detection algorithm used to
find apriltags. Works best of rectangles that have good contrast against the
background. The apriltag quad detection algorithm can handle any
scale/rotation/shear on rectangles. Returns a list of <a class="reference internal" href="#image.rect" title="image.rect"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.rect</span></code></a> objects.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p>Rectangles which have an edge magnitude (which is computed by sliding the
sobel operator across all pixels on the edges of the rectangle and summing
their values) less than <code class="docutils literal notranslate"><span class="pre">threshold</span></code> are filtered out of the returned list.
The correct value of <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is depended on your application/scene.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_qrcodes">
<span class="sig-name descname"><span class="pre">find_qrcodes</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_qrcodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all qrcodes within the <code class="docutils literal notranslate"><span class="pre">roi</span></code> and returns a list of <a class="reference internal" href="#image.qrcode" title="image.qrcode"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.qrcode</span></code></a>
objects. Please see the <a class="reference internal" href="#image.qrcode" title="image.qrcode"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.qrcode</span></code></a> object for more information.</p>
<p>QR Codes need to be relatively flat in the image for this method to work.
You can achieve a flatter image that is not effected by lens distortion by
either using the <a class="reference internal" href="omv.sensor.html#sensor.set_windowing" title="sensor.set_windowing"><code class="xref any py py-func docutils literal notranslate"><span class="pre">sensor.set_windowing()</span></code></a> function to zoom in the on the
center of the lens, <a class="reference internal" href="#image.Image.lens_corr" title="image.Image.lens_corr"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.lens_corr()</span></code></a> to undo lens barrel distortion, or
by just changing out the lens for something with a narrower fields of view.
There are machine vision lenses available which do not cause barrel
distortion but they are much more expensive to than the standard lenses
supplied by OpenMV.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_apriltags">
<span class="sig-name descname"><span class="pre">find_apriltags</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">families=image.TAG36H11</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">fy</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">cx</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">cy</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_apriltags" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all apriltags within the <code class="docutils literal notranslate"><span class="pre">roi</span></code> and returns a list of <a class="reference internal" href="#image.apriltag" title="image.apriltag"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.apriltag</span></code></a>
objects. Please see the <a class="reference internal" href="#image.apriltag" title="image.apriltag"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.apriltag</span></code></a> object for more information.</p>
<p>Unlike QR Codes, AprilTags can be detected at much farther distances, worse
lighting, in warped images, etc. AprilTags are robust too all kinds of
image distortion issues that QR Codes are not to. That said, AprilTags
can only encode a numeric ID as their payload.</p>
<p>AprilTags can also be used for localization purposes. Each <a class="reference internal" href="#image.apriltag" title="image.apriltag"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.apriltag</span></code></a>
object returns its translation and rotation from the camera. The units
of the translation are determined by <code class="docutils literal notranslate"><span class="pre">fx</span></code>, <code class="docutils literal notranslate"><span class="pre">fy</span></code>, <code class="docutils literal notranslate"><span class="pre">cx</span></code>, and <code class="docutils literal notranslate"><span class="pre">cy</span></code>
which are the focal lengths and center points of the image in the X and
Y directions respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To create AprilTags use the tag generator tool built-in to OpenMV IDE.
The tag generator can create printable 8.5”x11” AprilTags.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">families</span></code> is bitmask of tag families to decode. It is the logical OR of:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.TAG16H5" title="image.TAG16H5"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG16H5</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.TAG25H7" title="image.TAG25H7"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG25H7</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.TAG25H9" title="image.TAG25H9"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG25H9</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.TAG36H10" title="image.TAG36H10"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG36H10</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.TAG36H11" title="image.TAG36H11"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG36H11</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.ARTOOLKIT" title="image.ARTOOLKIT"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.ARTOOLKIT</span></code></a></p></li>
</ul>
</div></blockquote>
<p>By default it is just <a class="reference internal" href="#image.TAG36H11" title="image.TAG36H11"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.TAG36H11</span></code></a> which is the best tag family to
use. Note that <a class="reference internal" href="#image.Image.find_apriltags" title="image.Image.find_apriltags"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_apriltags()</span></code></a> slows down per enabled tag family.</p>
<p><code class="docutils literal notranslate"><span class="pre">fx</span></code> is the camera X focal length in pixels. For the standard OpenMV Cam
this is (2.8 / 3.984) * 656. Which is the lens focal length in mm, divided
by the camera sensor length in the X direction multiplied by the number of
camera sensor pixels in the X direction (for the OV7725 camera).</p>
<p><code class="docutils literal notranslate"><span class="pre">fx</span></code> is the camera Y focal length in pixels. For the standard OpenMV Cam
this is (2.8 / 2.952) * 488. Which is the lens focal length in mm, divided
by the camera sensor length in the Y direction multiplied by the number of
camera sensor pixels in the Y direction (for the OV7725 camera).</p>
<p><code class="docutils literal notranslate"><span class="pre">cx</span></code> is the image center which is just <code class="docutils literal notranslate"><span class="pre">image.width()/2</span></code>. This is not
<code class="docutils literal notranslate"><span class="pre">roi.w()/2</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">cy</span></code> is the image center which is just <code class="docutils literal notranslate"><span class="pre">image.height()/2</span></code>. This is not
<code class="docutils literal notranslate"><span class="pre">roi.h()/2</span></code>.</p>
<p>Not supported on compressed images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_datamatrices">
<span class="sig-name descname"><span class="pre">find_datamatrices</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">effort=200</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_datamatrices" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all datamatrices within the <code class="docutils literal notranslate"><span class="pre">roi</span></code> and returns a list of <a class="reference internal" href="#image.datamatrix" title="image.datamatrix"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.datamatrix</span></code></a>
objects. Please see the <a class="reference internal" href="#image.datamatrix" title="image.datamatrix"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.datamatrix</span></code></a> object for more information.</p>
<p>Data Matrices need to be relatively flat in the image for this method to work.
You can achieve a flatter image that is not effected by lens distortion by
either using the <a class="reference internal" href="omv.sensor.html#sensor.set_windowing" title="sensor.set_windowing"><code class="xref any py py-func docutils literal notranslate"><span class="pre">sensor.set_windowing()</span></code></a> function to zoom in the on the
center of the lens, <a class="reference internal" href="#image.Image.lens_corr" title="image.Image.lens_corr"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.lens_corr()</span></code></a> to undo lens barrel distortion, or
by just changing out the lens for something with a narrower fields of view.
There are machine vision lenses available which do not cause barrel
distortion but they are much more expensive to than the standard lenses
supplied by OpenMV.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">effort</span></code> controls how much time to spend trying to find data matrix matches.
The default value of 200 should be good for all use-cases. However, you may
increase the effort, at a cost of the frame rate, to increase detection. You
may also lower the effort to increase the frame rate, but, at a cost of
detections… note that when <code class="docutils literal notranslate"><span class="pre">effort</span></code> is set to below 160 or so you will
not detect anything anymore. Also note that you can make <code class="docutils literal notranslate"><span class="pre">effort</span></code> as high
as you like. But, any values above 240 or so do not result in much increase
in the detection rate.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_barcodes">
<span class="sig-name descname"><span class="pre">find_barcodes</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_barcodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all 1D barcodes within the <code class="docutils literal notranslate"><span class="pre">roi</span></code> and returns a list of <a class="reference internal" href="#image.barcode" title="image.barcode"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.barcode</span></code></a>
objects. Please see the <a class="reference internal" href="#image.barcode" title="image.barcode"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.barcode</span></code></a> object for more information.</p>
<p>For best results use a 640 by 40/80/160 window. The lower the vertical res
the faster everything will run. Since bar codes are linear 1D images you
just need a lot of resolution in one direction and just a little resolution
in the other direction. Note that this function scans both horizontally and
vertically so you can use a 40/80/160 by 480 window if you want. Finally,
make sure to adjust your lens so that the bar code is positioned where the
focal length produces the sharpest image. Blurry bar codes can’t be decoded.</p>
<p>This function supports all these 1D barcodes (basically all barcodes):</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#image.EAN2" title="image.EAN2"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EAN2</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.EAN5" title="image.EAN5"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EAN5</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.EAN8" title="image.EAN8"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EAN8</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.UPCE" title="image.UPCE"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.UPCE</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.ISBN10" title="image.ISBN10"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.ISBN10</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.UPCA" title="image.UPCA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.UPCA</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.EAN13" title="image.EAN13"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.EAN13</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.ISBN13" title="image.ISBN13"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.ISBN13</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.I25" title="image.I25"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.I25</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.DATABAR" title="image.DATABAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.DATABAR</span></code></a> (RSS-14)</p></li>
<li><p><a class="reference internal" href="#image.DATABAR_EXP" title="image.DATABAR_EXP"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.DATABAR_EXP</span></code></a> (RSS-Expanded)</p></li>
<li><p><a class="reference internal" href="#image.CODABAR" title="image.CODABAR"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CODABAR</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.CODE39" title="image.CODE39"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CODE39</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.PDF417" title="image.PDF417"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.PDF417</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.CODE93" title="image.CODE93"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CODE93</span></code></a></p></li>
<li><p><a class="reference internal" href="#image.CODE128" title="image.CODE128"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CODE128</span></code></a></p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_displacement">
<span class="sig-name descname"><span class="pre">find_displacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">template</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">template_roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">logpolar=False</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_displacement" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the translation offset of the this image from the template. This
method can be used to do optical flow. This method returns a <a class="reference internal" href="#image.displacement" title="image.displacement"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.displacement</span></code></a>
object with the results of the displacement calculation using phase correlation.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle (x, y, w, h) to work in.
If not specified, it is equal to the image rectangle.</p>
<p><code class="docutils literal notranslate"><span class="pre">template_roi</span></code> is the region-of-interest rectangle (x, y, w, h) to work in.
If not specified, it is equal to the image rectangle.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> and <code class="docutils literal notranslate"><span class="pre">template</span></code> roi must have the same w/h but may have any x/y
location in the image. You may slide smaller rois arround a larger image to
get an optical flow gradient image…</p>
<p><a class="reference internal" href="#image.Image.find_displacement" title="image.Image.find_displacement"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_displacement()</span></code></a> normally computes the x/y translation between two
images. However, if you pass <code class="docutils literal notranslate"><span class="pre">logpolar=True</span></code> it will instead find rotation
and scale changes between the two images. The same <a class="reference internal" href="#image.displacement" title="image.displacement"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.displacement</span></code></a> object
result encodes both possible repsonses.</p>
<p>Not supported on compressed images or bayer images.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please use this method on power-of-2 image sizes (e.g. <a class="reference internal" href="omv.sensor.html#sensor.B64X64" title="sensor.B64X64"><code class="xref any py py-data docutils literal notranslate"><span class="pre">sensor.B64X64</span></code></a>).</p>
</div>
<p>Not supported on compressed images or bayer images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_template">
<span class="sig-name descname"><span class="pre">find_template</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">step=2</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">search=image.SEARCH_EX</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_template" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to find the first location in the image where template matches using
Normalized Cross Correlation. Returns a bounding box tuple (x, y, w, h) for
the matching location otherwise None.</p>
<p><code class="docutils literal notranslate"><span class="pre">template</span></code> is a small image object that is matched against this image
object. Note that both images must be grayscale.</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> is floating point number (0.0-1.0) where a higher threshold
prevents false positives while lowering the detection rate while a lower
threshold does the opposite.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">step</span></code> is the number of pixels to skip past while looking for the
template. Skipping pixels considerably speeds the algorithm up. This only
affects the algorithm in SERACH_EX mode.</p>
<p><code class="docutils literal notranslate"><span class="pre">search</span></code> can be either <code class="docutils literal notranslate"><span class="pre">image.SEARCH_DS</span></code> or <code class="docutils literal notranslate"><span class="pre">image.SEARCH_EX</span></code>.
<code class="docutils literal notranslate"><span class="pre">image.SEARCH_DS</span></code> searches for the template using as faster algorithm
than <code class="docutils literal notranslate"><span class="pre">image.SEARCH_EX</span></code> but may not find the template if it’s near the
edges of the image. <code class="docutils literal notranslate"><span class="pre">image.SEARCH_EX</span></code> does an exhaustive search for the
image but can be much slower than <code class="docutils literal notranslate"><span class="pre">image.SEARCH_DS</span></code>.</p>
<p>Only works on grayscale images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_features">
<span class="sig-name descname"><span class="pre">find_features</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cascade</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=0.5</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">scale=1.5</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_features" title="Permalink to this definition">¶</a></dt>
<dd><p>This method searches the image for all areas that match the passed in Haar
Cascade and returns a list of bounding box rectangles tuples (x, y, w, h)
around those features. Returns an empty list if no features are found.</p>
<p><code class="docutils literal notranslate"><span class="pre">cascade</span></code> is a Haar Cascade object. See <a class="reference internal" href="#image.HaarCascade" title="image.HaarCascade"><code class="xref any py py-class docutils literal notranslate"><span class="pre">image.HaarCascade()</span></code></a> for more
details.</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> is a threshold (0.0-1.0) where a smaller value increase the
detection rate while raising the false positive rate. Conversely, a higher
value decreases the detection rate while lowering the false positive rate.</p>
<p><code class="docutils literal notranslate"><span class="pre">scale</span></code> is a float that must be greater than 1.0. A higher scale
factor will run faster but will have much poorer image matches. A good
value is between 1.35 and 1.5.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_eye">
<span class="sig-name descname"><span class="pre">find_eye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches for the pupil in a region-of-interest (x, y, w, h) tuple around an
eye. Returns a tuple with the (x, y) location of the pupil in the image.
Returns (0,0) if no pupils are found.</p>
<p>To use this function first use <a class="reference internal" href="#image.Image.find_features" title="image.Image.find_features"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_features()</span></code></a> with the
<code class="docutils literal notranslate"><span class="pre">frontalface</span></code> HaarCascade to find someone’s face. Then use
<a class="reference internal" href="#image.Image.find_features" title="image.Image.find_features"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_features()</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">eye</span></code> HaarCascade to find the eyes on the
face. Finally, call this method on the eye ROI returned by
<a class="reference internal" href="#image.Image.find_features" title="image.Image.find_features"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Image.find_features()</span></code></a> to get the pupil coordinates.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p>Only works on grayscale images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_lbp">
<span class="sig-name descname"><span class="pre">find_lbp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_lbp" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts LBP (local-binary-patterns) keypoints from the region-of-interest
(x, y, w, h) tuple. You can then use then use the <a class="reference internal" href="#image.match_descriptor" title="image.match_descriptor"><code class="xref any py py-func docutils literal notranslate"><span class="pre">image.match_descriptor()</span></code></a>
function to compare two sets of keypoints to get the matching distance.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p>Only works on grayscale images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_keypoints">
<span class="sig-name descname"><span class="pre">find_keypoints</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=20</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">normalized=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">scale_factor=1.5</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">max_keypoints=100</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">corner_detector=image.CORNER_AGAST</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_keypoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts ORB keypoints from the region-of-interest (x, y, w, h) tuple. You
can then use then use the <a class="reference internal" href="#image.match_descriptor" title="image.match_descriptor"><code class="xref any py py-func docutils literal notranslate"><span class="pre">image.match_descriptor()</span></code></a> function to compare
two sets of keypoints to get the matching areas. Returns None if no
keypoints were found.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> is a number (between 0 - 255) which controls the number of
extracted corners. For the default AGAST corner detector this should be
around 20. FOr the FAST corner detector this should be around 60-80. The
lower the threshold the more extracted corners you get.</p>
<p><code class="docutils literal notranslate"><span class="pre">normalized</span></code> is a boolean value that if True turns off extracting
keypoints at multiple resolutions. Set this to true if you don’t care
about dealing with scaling issues and want the algorithm to run faster.</p>
<p><code class="docutils literal notranslate"><span class="pre">scale_factor</span></code> is a float that must be greater than 1.0. A higher scale
factor will run faster but will have much poorer image matches. A good
value is between 1.35 and 1.5.</p>
<p><code class="docutils literal notranslate"><span class="pre">max_keypoints</span></code> is the maximum number of keypoints a keypoint object may
hold. If keypoint objects are too big and causing out of RAM issues then
decrease this value.</p>
<p><code class="docutils literal notranslate"><span class="pre">corner_detector</span></code> is the corner detector algorithm to use which extracts
keypoints from the image. It can be either <a class="reference internal" href="#image.CORNER_FAST" title="image.CORNER_FAST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CORNER_FAST</span></code></a> or
<a class="reference internal" href="#image.CORNER_AGAST" title="image.CORNER_AGAST"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.CORNER_AGAST</span></code></a>. The FAST corner detector is faster but much less accurate.</p>
<p>Only works on grayscale images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_edges">
<span class="sig-name descname"><span class="pre">find_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edge_type</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Turns the image to black and white leaving only the edges as white pixels.</p>
<blockquote>
<div><ul class="simple">
<li><p>image.EDGE_SIMPLE - Simple thresholded high pass filter algorithm.</p></li>
<li><p>image.EDGE_CANNY - Canny edge detection algorithm.</p></li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> is a two valued tuple containing a low threshold and high
threshold. You can control the quality of edges by adjusting these values.
It defaults to (100, 200).</p>
<p>Only works on grayscale images.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.find_hog">
<span class="sig-name descname"><span class="pre">find_hog</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">roi</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">size=8</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.find_hog" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the pixels in the ROI with HOG (histogram of orientated graidients)
lines.</p>
<p><code class="docutils literal notranslate"><span class="pre">roi</span></code> is the region-of-interest rectangle tuple (x, y, w, h). If not
specified, it is equal to the image rectangle. Only pixels within the
<code class="docutils literal notranslate"><span class="pre">roi</span></code> are operated on.</p>
<p>Only works on grayscale images.</p>
<p>This method is not available on the OpenMV Cam M4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="image.Image.stero_disparity">
<span class="sig-name descname"><span class="pre">stero_disparity</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">reversed=False</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">max_disparity=64</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold=64</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#image.Image.stero_disparity" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a double wide grayscale image that contains the output of two camera sensors
side-by-side and replaces one of the images int he double wide image with the stero-disparity
image where each pixel reprsents depth. E.g. if you have two 320x240 cameras then this method
takes a 640x240 image.</p>
<p><code class="docutils literal notranslate"><span class="pre">reversed</span></code> By default the left image is compared to the right image and the right image
is then replaced. Pass true to compare the right image to the left image and replace the left
image.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The algorithm only works comparing left-&gt;right or right-&gt;left. If your camrea setup does
not match this then you will get useless results.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">max_disparity</span></code> is the maximum distance to search for a matching pixel block using the
sum-of-absolute differences algorith. Larger values take exponentially longer to search with
but result in higher quality images. Lower values make the algorithm run faster but may
result in nonsense output.</p>
<p><code class="docutils literal notranslate"><span class="pre">threshold</span></code> if the sum-of-absolute differences between two blocks is less than or equal
to this threshold they are considered to be matching.</p>
<p>This method is only available on the Arduino Portenta.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Even with our best SIMD effort this algorithm is not real-time on the Cortex-M7 processor.
This is just a toy example algorithm showing off stero-disparity.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="constants">
<h2>Constants<a class="headerlink" href="#constants" title="Permalink to this heading">¶</a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="image.BINARY">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">BINARY</span></span><a class="headerlink" href="#image.BINARY" title="Permalink to this definition">¶</a></dt>
<dd><p>BINARY (bitmap) pixel format. Each pixel is 1-bit.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.GRAYSCALE">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">GRAYSCALE</span></span><a class="headerlink" href="#image.GRAYSCALE" title="Permalink to this definition">¶</a></dt>
<dd><p>GRAYSCALE pixel format. Each pixel is 8-bits, 1-byte.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.RGB565">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">RGB565</span></span><a class="headerlink" href="#image.RGB565" title="Permalink to this definition">¶</a></dt>
<dd><p>RGB565 pixel format. Each pixel is 16-bits, 2-bytes. 5-bits are used for red,
6-bits are used for green, and 5-bits are used for blue.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.BAYER">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">BAYER</span></span><a class="headerlink" href="#image.BAYER" title="Permalink to this definition">¶</a></dt>
<dd><p>RAW BAYER image pixel format. If you try to make the frame size too big
to fit in the frame buffer your OpenMV Cam will set the pixel format
to BAYER so that you can capture images but no image processing methods
will be operational.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.YUV422">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">YUV422</span></span><a class="headerlink" href="#image.YUV422" title="Permalink to this definition">¶</a></dt>
<dd><p>A pixel format that is very easy to jpeg compress. Each pixel is stored as a grayscale
8-bit Y value followed by alternating 8-bit U/V color values that are shared between two
Y values (8-bits Y1, 8-bits U, 8-bits Y2, 8-bits V, etc.). Only some image processing
methods work with YUV422.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.JPEG">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">JPEG</span></span><a class="headerlink" href="#image.JPEG" title="Permalink to this definition">¶</a></dt>
<dd><p>A JPEG image.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.PNG">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">PNG</span></span><a class="headerlink" href="#image.PNG" title="Permalink to this definition">¶</a></dt>
<dd><p>A PNG image.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.AREA">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">AREA</span></span><a class="headerlink" href="#image.AREA" title="Permalink to this definition">¶</a></dt>
<dd><p>Use area scaling when downscaling an image (Nearest Neighbor is used for upscaling).</p>
<p>You should use area scaling when downscaling for the highest visual quality.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.BILINEAR">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">BILINEAR</span></span><a class="headerlink" href="#image.BILINEAR" title="Permalink to this definition">¶</a></dt>
<dd><p>Use bilinear scaling when upscaling an image. This produces a good quality scaled image output
and is fast.</p>
<p>When downscaling an image this method will subsample the input image to produce the downscaled
image. Use <a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a> for the higest quality downscaling if speed is not an issue.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.BICUBIC">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">BICUBIC</span></span><a class="headerlink" href="#image.BICUBIC" title="Permalink to this definition">¶</a></dt>
<dd><p>Use bicubic scaling when upscaling an image. This produces a high quality scaled image output,
but is slow.</p>
<p>When downscaling an image this method will subsample the input image to produce the downscaled
image. Use <a class="reference internal" href="#image.AREA" title="image.AREA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">image.AREA</span></code></a> for the higest quality downscaling if speed is not an issue.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.CENTER">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">CENTER</span></span><a class="headerlink" href="#image.CENTER" title="Permalink to this definition">¶</a></dt>
<dd><p>Anchor the image being drawn with <a class="reference internal" href="#image.Image.draw_image" title="image.Image.draw_image"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">draw_image</span></code></a> in the center versus the top left hand corner.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.EXTRACT_RGB_CHANNEL_FIRST">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">EXTRACT_RGB_CHANNEL_FIRST</span></span><a class="headerlink" href="#image.EXTRACT_RGB_CHANNEL_FIRST" title="Permalink to this definition">¶</a></dt>
<dd><p>When extracting an RGB channel from an RGB image using <a class="reference internal" href="#image.Image.draw_image" title="image.Image.draw_image"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">draw_image</span></code></a> extract the channel first
before scaling versus afterwards to prevent any artifacts.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.APPLY_COLOR_PALETTE_FIRST">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">APPLY_COLOR_PALETTE_FIRST</span></span><a class="headerlink" href="#image.APPLY_COLOR_PALETTE_FIRST" title="Permalink to this definition">¶</a></dt>
<dd><p>When applying a color lookup table to an image using <a class="reference internal" href="#image.Image.draw_image" title="image.Image.draw_image"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">draw_image</span></code></a> apply the color look table
first before scaling versus afterwards to prevent any artifacts.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.BLACK_BACKGROUND">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">BLACK_BACKGROUND</span></span><a class="headerlink" href="#image.BLACK_BACKGROUND" title="Permalink to this definition">¶</a></dt>
<dd><p>Speeds up <a class="reference internal" href="#image.Image.draw_image" title="image.Image.draw_image"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">draw_image</span></code></a> when drawing on a black destination image when using alpha effects that
require reading both source and destination pixels. This skips reading the destination pixel.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.SEARCH_EX">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">SEARCH_EX</span></span><a class="headerlink" href="#image.SEARCH_EX" title="Permalink to this definition">¶</a></dt>
<dd><p>Exhaustive template matching search.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.SEARCH_DS">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">SEARCH_DS</span></span><a class="headerlink" href="#image.SEARCH_DS" title="Permalink to this definition">¶</a></dt>
<dd><p>Faster template matching search.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.EDGE_CANNY">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">EDGE_CANNY</span></span><a class="headerlink" href="#image.EDGE_CANNY" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the canny edge detection algorithm for doing edge detection on an image.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.EDGE_SIMPLE">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">EDGE_SIMPLE</span></span><a class="headerlink" href="#image.EDGE_SIMPLE" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a simple thresholded high pass filter algorithm for doing edge detection
on an image.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.CORNER_FAST">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">CORNER_FAST</span></span><a class="headerlink" href="#image.CORNER_FAST" title="Permalink to this definition">¶</a></dt>
<dd><p>Faster and less accurate corner detection algorithm for ORB keypoints.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.CORNER_AGAST">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">CORNER_AGAST</span></span><a class="headerlink" href="#image.CORNER_AGAST" title="Permalink to this definition">¶</a></dt>
<dd><p>Slower and more accurate corner detection algorithm for ORB keypoints.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.TAG16H5">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">TAG16H5</span></span><a class="headerlink" href="#image.TAG16H5" title="Permalink to this definition">¶</a></dt>
<dd><p>TAG1H5 tag family bit mask enum. Used for AprilTags.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.TAG25H7">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">TAG25H7</span></span><a class="headerlink" href="#image.TAG25H7" title="Permalink to this definition">¶</a></dt>
<dd><p>TAG25H7 tag family bit mask enum. Used for AprilTags.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.TAG25H9">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">TAG25H9</span></span><a class="headerlink" href="#image.TAG25H9" title="Permalink to this definition">¶</a></dt>
<dd><p>TAG25H9 tag family bit mask enum. Used for AprilTags.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.TAG36H10">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">TAG36H10</span></span><a class="headerlink" href="#image.TAG36H10" title="Permalink to this definition">¶</a></dt>
<dd><p>TAG36H10 tag family bit mask enum. Used for AprilTags.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.TAG36H11">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">TAG36H11</span></span><a class="headerlink" href="#image.TAG36H11" title="Permalink to this definition">¶</a></dt>
<dd><p>TAG36H11 tag family bit mask enum. Used for AprilTags.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.ARTOOLKIT">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">ARTOOLKIT</span></span><a class="headerlink" href="#image.ARTOOLKIT" title="Permalink to this definition">¶</a></dt>
<dd><p>ARTOOLKIT tag family bit mask enum. Used for AprilTags.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.EAN2">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">EAN2</span></span><a class="headerlink" href="#image.EAN2" title="Permalink to this definition">¶</a></dt>
<dd><p>EAN2 barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.EAN5">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">EAN5</span></span><a class="headerlink" href="#image.EAN5" title="Permalink to this definition">¶</a></dt>
<dd><p>EAN5 barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.EAN8">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">EAN8</span></span><a class="headerlink" href="#image.EAN8" title="Permalink to this definition">¶</a></dt>
<dd><p>EAN8 barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.UPCE">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">UPCE</span></span><a class="headerlink" href="#image.UPCE" title="Permalink to this definition">¶</a></dt>
<dd><p>UPCE barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.ISBN10">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">ISBN10</span></span><a class="headerlink" href="#image.ISBN10" title="Permalink to this definition">¶</a></dt>
<dd><p>ISBN10 barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.UPCA">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">UPCA</span></span><a class="headerlink" href="#image.UPCA" title="Permalink to this definition">¶</a></dt>
<dd><p>UPCA barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.EAN13">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">EAN13</span></span><a class="headerlink" href="#image.EAN13" title="Permalink to this definition">¶</a></dt>
<dd><p>EAN13 barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.ISBN13">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">ISBN13</span></span><a class="headerlink" href="#image.ISBN13" title="Permalink to this definition">¶</a></dt>
<dd><p>ISBN13 barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.I25">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">I25</span></span><a class="headerlink" href="#image.I25" title="Permalink to this definition">¶</a></dt>
<dd><p>I25 barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.DATABAR">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">DATABAR</span></span><a class="headerlink" href="#image.DATABAR" title="Permalink to this definition">¶</a></dt>
<dd><p>DATABAR barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.DATABAR_EXP">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">DATABAR_EXP</span></span><a class="headerlink" href="#image.DATABAR_EXP" title="Permalink to this definition">¶</a></dt>
<dd><p>DATABAR_EXP barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.CODABAR">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">CODABAR</span></span><a class="headerlink" href="#image.CODABAR" title="Permalink to this definition">¶</a></dt>
<dd><p>CODABAR barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.CODE39">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">CODE39</span></span><a class="headerlink" href="#image.CODE39" title="Permalink to this definition">¶</a></dt>
<dd><p>CODE39 barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.PDF417">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">PDF417</span></span><a class="headerlink" href="#image.PDF417" title="Permalink to this definition">¶</a></dt>
<dd><p>PDF417 barcode type enum - Future (e.g. doesn’t work right now).</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.CODE93">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">CODE93</span></span><a class="headerlink" href="#image.CODE93" title="Permalink to this definition">¶</a></dt>
<dd><p>CODE93 barcode type enum.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="image.CODE128">
<span class="sig-prename descclassname"><span class="pre">image.</span></span><span class="sig-name descname"><span class="pre">CODE128</span></span><a class="headerlink" href="#image.CODE128" title="Permalink to this definition">¶</a></dt>
<dd><p>CODE128 barcode type enum.</p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="omv.sensor.html" class="btn btn-neutral float-left" title="sensor — camera sensor" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="omv.tf.html" class="btn btn-neutral float-right" title="tf — Tensor Flow" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright - The MicroPython Documentation is Copyright © 2014-2023, Damien P. George, Paul Sokolovsky, and contributors.
      <span class="lastupdated">Last updated on 02 May 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Language and External Links</span>
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Language</dt>
      <dd>
        <a href="https://openmv.io">English</a>
      </dd>
      <dd>
        <a href="http://doc.singtown.cc">中文</a>
      </dd>
    </dl>
    <hr/>
    <dl>
      <dt>External links</dt>
      <dd>
        <a href="https://openmv.io">openmv.io</a>
      </dd>
      <dd>
        <a href="http://forums.openmv.io">forums.openmv.io</a>
      </dd>
      <dd>
        <a href="https://github.com/openmv/openmv">github.com/openmv/openmv</a>
      </dd>
      <dd>
        <a href="http://micropython.org">micropython.org</a>
      </dd>
      <dd>
        <a href="http://forum.micropython.org">forum.micropython.org</a>
      </dd>
      <dd>
        <a href="https://github.com/micropython/micropython">github.com/micropython/micropython</a>
      </dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>