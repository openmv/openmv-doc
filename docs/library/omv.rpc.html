
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>rpc — rpc library &#8212; MicroPython 1.19 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/customstyle.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    
    <link rel="shortcut icon" href="../_static/openmv.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="rtsp — rtsp library" href="omv.rtsp.html" />
    <link rel="prev" title="imu — imu sensor" href="omv.imu.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="omv.rtsp.html" title="rtsp — rtsp library"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="omv.imu.html" title="imu — imu sensor"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MicroPython 1.19 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">MicroPython libraries</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-rpc">
<span id="rpc-rpc-library"></span><h1><a class="reference internal" href="#module-rpc" title="rpc: rpc library"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rpc</span></code></a> — rpc library<a class="headerlink" href="#module-rpc" title="Permalink to this headline">¶</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">rpc</span></code> module on the OpenMV Cam allows you to connect your OpenMV Cam to another microcontroller
or computer and execute remote python (or procedure) calls on your OpenMV Cam. The <code class="docutils literal notranslate"><span class="pre">rpc</span></code> module also
allows for the reverse too if you want your OpenMV Cam to be able to execute remote procedure
(or python) calls on another microcontroller or computer.</p>
<div class="section" id="how-to-use-the-library">
<h2>How to use the Library<a class="headerlink" href="#how-to-use-the-library" title="Permalink to this headline">¶</a></h2>
<p>Please checkout the example scripts in OpenMV IDE under <code class="docutils literal notranslate"><span class="pre">Remote</span> <span class="pre">Control</span></code>.</p>
<p>You will need to edit the example code to choose which interface you want to use and to play with
the settings the scripts use.</p>
<p>In general, for the controller device to use the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library you will create an interface object
using the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interface</span> <span class="o">=</span> <span class="n">rpc</span><span class="o">.</span><span class="n">rpc_uart_master</span><span class="p">(</span><span class="n">baudrate</span><span class="o">=</span><span class="mi">115200</span><span class="p">)</span>
</pre></div>
</div>
<p>This create a UART interface to talk to an <code class="docutils literal notranslate"><span class="pre">rpc</span></code> slave.</p>
<p>Once the interface is created you just need to do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">memory_view_object_result</span> <span class="o">=</span> <span class="n">interface</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;remote_function_or_method_name&quot;</span><span class="p">,</span> <span class="n">bytes_object_argument</span><span class="p">)</span>
</pre></div>
</div>
<p>And the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library will try to execute that <code class="docutils literal notranslate"><span class="pre">&quot;remote_function_or_method_name&quot;</span></code> on the slave. The
remote function or method will receive the <code class="docutils literal notranslate"><span class="pre">bytes_object_argument</span></code> which can be up to 2^32-1 bytes in
size. Once the remote method finishes executing it will return a <code class="docutils literal notranslate"><span class="pre">memory_view_object_result</span></code> which
can also be up to 2^32-1 bytes in size. Because the argument and response are both generic byte
containers you can pass anything through the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library and receive any type of response. A simple
way to pass arguments is to use <code class="docutils literal notranslate"><span class="pre">struct.pack()</span></code> to create the argument and <code class="docutils literal notranslate"><span class="pre">struct.unpack()</span></code> to
receieve the argument on the other side. For the response, the other side may send a string
object or json string as the result which the master can then interpret.</p>
<p>As for errors, if you try to execute a non-existant function or method name the
<code class="docutils literal notranslate"><span class="pre">rpc_master.call()</span></code> method will return an empty <code class="docutils literal notranslate"><span class="pre">bytes()</span></code> object. If the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library failed to communicate with the
slave the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library will return None.</p>
<p>To keep things simple the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library doesn’t maintain a connection between the master and slave
devices. The <code class="docutils literal notranslate"><span class="pre">rpc_master.call()</span></code> method encapsulates trying to connect to the slave, starting execution of
the remote function or method, and getting the result.</p>
<p>Now, on the slave side of things you have to create an <code class="docutils literal notranslate"><span class="pre">rpc</span></code> interface to communicate with the
master. This looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interface</span> <span class="o">=</span> <span class="n">rpc</span><span class="o">.</span><span class="n">rpc_uart_slave</span><span class="p">(</span><span class="n">baudrate</span><span class="o">=</span><span class="mi">115200</span><span class="p">)</span>
</pre></div>
</div>
<p>This will create the UART interface layer to talk to an <code class="docutils literal notranslate"><span class="pre">rpc</span></code> master.</p>
<p>Once you create the slave interface you then need to register call backs that the master can call
with the interface object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remote_function_or_method_name</span><span class="p">(</span><span class="n">memoryview_object_argument</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">lots</span> <span class="n">of</span> <span class="n">code</span><span class="o">&gt;</span>
    <span class="k">return</span> <span class="n">bytes_object_result</span>

<span class="n">interface</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">remote_function_or_method_name</span><span class="p">)</span>
</pre></div>
</div>
<p>You may register as many callbacks as you like on the slave.
Finally, once you are done registering callbacks you just need to execute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interface</span><span class="o">.</span><span class="n">loop</span><span class="p">()</span>
</pre></div>
</div>
<p>On the slave to start the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library up and begin listening for the master. Note that the
<code class="docutils literal notranslate"><span class="pre">rpc_slave.loop()</span></code> method does not return. Also, to make your slave more robust against errors you may
want to wrap the <code class="docutils literal notranslate"><span class="pre">rpc_slave.loop()</span></code> with <code class="docutils literal notranslate"><span class="pre">try:</span></code> and <code class="docutils literal notranslate"><span class="pre">except:</span></code> for whatever exceptions might be thrown by your
callback methods. The <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library will not generate any exceptions itself. Note: passing large data
structures around (like jpeg images) can potentially exhaust the heap on the OpenMV Cam and generate
<a class="reference internal" href="builtins.html#MemoryError" title="MemoryError"><code class="xref any py py-exc docutils literal notranslate"><span class="pre">MemoryError</span></code></a> exceptions.</p>
<p>And that is it! The <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library is designed to be simple to use.</p>
</div>
<div class="section" id="class-rpc-rpc-virtual-class">
<h2>class rpc - rpc virtual class<a class="headerlink" href="#class-rpc-rpc-virtual-class" title="Permalink to this headline">¶</a></h2>
<p>The rpc base class is reimplemented by the <a class="reference internal" href="#rpc.rpc_master" title="rpc.rpc_master"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rpc_master</span></code></a> and <a class="reference internal" href="#rpc.rpc_slave" title="rpc.rpc_slave"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rpc_slave</span></code></a> classes to create the master
and slave interfaces. It is a pure virtual class and not meant to be used directly.</p>
<div class="section" id="constructors">
<h3>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="rpc.rpc">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc</code><a class="headerlink" href="#rpc.rpc" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an rpc object. This constructor is not meant to be used directly.</p>
<dl class="method">
<dt>
<code class="sig-name descname">get_bytes(buff, timeout_ms):</code></dt>
<dd><p>This method is meant to be reimplemented by specific interface classes of <a class="reference internal" href="#rpc.rpc_master" title="rpc.rpc_master"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rpc_master</span></code></a> and <a class="reference internal" href="#rpc.rpc_slave" title="rpc.rpc_slave"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rpc_slave</span></code></a>.
It should fill the <code class="docutils literal notranslate"><span class="pre">buff</span></code> argument which is either a <a class="reference internal" href="builtins.html#bytearray" title="bytearray"><code class="xref any py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> or <a class="reference internal" href="builtins.html#memoryview" title="memoryview"><code class="xref any py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> object of bytes from the
interface equal to the length of the <code class="docutils literal notranslate"><span class="pre">buff</span></code> object in <code class="docutils literal notranslate"><span class="pre">timeout_ms</span></code> milliseconds. On timeout this method
should return <code class="docutils literal notranslate"><span class="pre">None</span></code>. Note that for master and slave synchronization this method should try to always
complete in at least <code class="docutils literal notranslate"><span class="pre">timeout_ms</span></code> milliseconds and not faster as the <a class="reference internal" href="#rpc.rpc_master" title="rpc.rpc_master"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rpc_master</span></code></a> and <a class="reference internal" href="#rpc.rpc_slave" title="rpc.rpc_slave"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rpc_slave</span></code></a> objects
will automatically increase the <code class="docutils literal notranslate"><span class="pre">timeout_ms</span></code> to synchronize.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">put_bytes(data, timeout_ms):</code></dt>
<dd><p>This method is meant to be reimplemented by specific interface classes of <a class="reference internal" href="#rpc.rpc_master" title="rpc.rpc_master"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rpc_master</span></code></a> and <a class="reference internal" href="#rpc.rpc_slave" title="rpc.rpc_slave"><code class="xref any py py-class docutils literal notranslate"><span class="pre">rpc_slave</span></code></a>.
It should send <code class="docutils literal notranslate"><span class="pre">data</span></code> bytes on the interface within <code class="docutils literal notranslate"><span class="pre">timeout_ms</span></code> milliseconds. If it completes faster
than the timeout that is okay. No return value is expected.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">stream_reader(call_back, queue_depth=1, read_timeout_ms=5000):</code></dt>
<dd><p>This method is meant to be called directly. After synchronization of the master and slave on return
of a callback <code class="docutils literal notranslate"><span class="pre">stream_reader</span></code> may be called to receive data as fast as possible from the master or
slave device. <code class="docutils literal notranslate"><span class="pre">call_back</span></code> will be called repeatedly with a <code class="docutils literal notranslate"><span class="pre">bytes_or_memory_view</span> <span class="pre">argument</span></code> that was
sent by the <code class="docutils literal notranslate"><span class="pre">stream_writer</span></code>. <code class="docutils literal notranslate"><span class="pre">call_back</span></code> is not expected to return anything. <code class="docutils literal notranslate"><span class="pre">queue_depth</span></code> defines how
many frames of data the <code class="docutils literal notranslate"><span class="pre">stream_writer</span></code> may generate before slowing down and waiting on the
<code class="docutils literal notranslate"><span class="pre">stream_reader</span></code>. Higher <code class="docutils literal notranslate"><span class="pre">queue_depth</span></code> values lead to higher performance (up to a point) but require the
<code class="docutils literal notranslate"><span class="pre">stream_reader</span></code> to be able to handle outstanding packets in its interface layer. If you make the
<code class="docutils literal notranslate"><span class="pre">queue_depth</span></code> larger than 1 then <code class="docutils literal notranslate"><span class="pre">call_back</span></code> should return very quickly and not block. Finally,
<code class="docutils literal notranslate"><span class="pre">read_timeout_ms</span></code> defines how many milliseconds to wait to receive the <code class="docutils literal notranslate"><span class="pre">bytes_or_memory_view</span></code> payload per call_back.</p>
<p>On any errors <code class="docutils literal notranslate"><span class="pre">stream_reader</span></code> will return. The master and slave devices can try to setup the stream
again afterwards to continue.</p>
<p>If you need to cancel the <code class="docutils literal notranslate"><span class="pre">stream_reader</span></code> just raise an exception in the <code class="docutils literal notranslate"><span class="pre">call_back</span></code> and catch it. The
remote side will automatically timeout.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">stream_writer(call_back, write_timeout_ms=5000):</code></dt>
<dd><p>This method is meant to be called directly. After synchronization of the master and slave on return
of a <code class="docutils literal notranslate"><span class="pre">callback</span></code> <code class="docutils literal notranslate"><span class="pre">stream_writer</span></code> may be called to send data as fast as possible from the master or slave
device. <code class="docutils literal notranslate"><span class="pre">call_back</span></code> will be called repeatedly and should return a <code class="docutils literal notranslate"><span class="pre">bytes_or_memory_view</span></code> object that
will be sent to the <code class="docutils literal notranslate"><span class="pre">stream_reader</span></code>. <code class="docutils literal notranslate"><span class="pre">call_back</span></code> should not take any arguments. Finally,
<code class="docutils literal notranslate"><span class="pre">write_timeout_ms</span></code> defines how many milliseconds to wait to send the <code class="docutils literal notranslate"><span class="pre">bytes_or_memory_view</span></code> object
returned by <code class="docutils literal notranslate"><span class="pre">call_back</span></code>.</p>
<p>On any errors <code class="docutils literal notranslate"><span class="pre">stream_writer</span></code> will return. The master and slave devices can try to setup the stream
again afterwards to continue.</p>
<p>If you need to cancel the <code class="docutils literal notranslate"><span class="pre">stream_writer</span></code> just raise an exception in the <code class="docutils literal notranslate"><span class="pre">call_back</span></code> and catch it. The
remote side will automatically timeout.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="class-rpc-master-rpc-master-virtual-class">
<h2>class rpc_master - rpc_master virtual class<a class="headerlink" href="#class-rpc-master-rpc-master-virtual-class" title="Permalink to this headline">¶</a></h2>
<p>The rpc_master is a pure virtual class and not meant to be used directly. Specific interface
classes should reimplement rpc_master.</p>
<div class="section" id="id1">
<h3>Constructors<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="rpc.rpc_master">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_master</code><a class="headerlink" href="#rpc.rpc_master" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an rpc_master object. This constructor is not meant to be used directly.</p>
<dl class="method">
<dt>
<code class="sig-name descname">call(name, data=bytes(), send_timeout=1000, recv_timeout=1000):</code></dt>
<dd><p>Executes a remote call on the slave device. <code class="docutils literal notranslate"><span class="pre">name</span></code> is a string name of the remote function or method
to execute. <code class="docutils literal notranslate"><span class="pre">data</span></code> is the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> like object that will be sent as the argument of the remote function
or method to exeucte. <code class="docutils literal notranslate"><span class="pre">send_timeout</span></code> defines how many milliseconds to wait while trying to connect to
the slave and get it to execute the remote function or method. Once the master starts sending the
argument to the slave deivce <code class="docutils literal notranslate"><span class="pre">send_timeout</span></code> does not apply. The library will allow the argument to
take up to 5 seconds to be sent. <code class="docutils literal notranslate"><span class="pre">recv_timeout</span></code> defines how many milliseconds to wait after the slave
started executing the remote method to receive the repsonse. Note that once the master starts
receiving the repsonse <code class="docutils literal notranslate"><span class="pre">recv_timeout</span></code> does not apply. The library will allow the response to take up
to 5 seconds to be received.</p>
<p>Note that a new packet that includes a copy of <code class="docutils literal notranslate"><span class="pre">data</span></code> will be created internally inside the <code class="docutils literal notranslate"><span class="pre">rpc</span></code>
library. You may encounter memory issues on the OpenMV Cam if you try to pass very large data
arguments.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="class-rpc-slave-rpc-slave-virtual-class">
<h2>class rpc_slave - rpc_slave virtual class<a class="headerlink" href="#class-rpc-slave-rpc-slave-virtual-class" title="Permalink to this headline">¶</a></h2>
<p>The rpc_slave is a pure virtual class and not meant to be used directly. Specific interface
classes should reimplement rpc_slave.</p>
<div class="section" id="id2">
<h3>Constructors<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="rpc.rpc_slave">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_slave</code><a class="headerlink" href="#rpc.rpc_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an rpc_slave object. This constructor is not meant to be used directly.</p>
<dl class="method">
<dt>
<code class="sig-name descname">register_callback(cb):</code></dt>
<dd><p>Registers a call back that can be executed by the master device. The call back should take one
argument which will be a <code class="docutils literal notranslate"><span class="pre">memoryview</span></code> object and it should return a <code class="docutils literal notranslate"><span class="pre">bytes()</span></code> like object as the
result. The call back should return in less than 1 second if possible.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">schedule_callback(cb):</code></dt>
<dd><p>After you execute <code class="docutils literal notranslate"><span class="pre">rpc_slave.loop()</span></code> it is not possible to execute long running operations outside of the <code class="docutils literal notranslate"><span class="pre">rpc</span></code>
library. <code class="docutils literal notranslate"><span class="pre">schedule_callback</span></code> allows you to break out of the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library temporarily after completion
of an call back. You should execute <code class="docutils literal notranslate"><span class="pre">schedule_callback</span></code> during the execution of an <code class="docutils literal notranslate"><span class="pre">rpc</span></code> call back
method to register a new non-rpc call back that will be executed immediately after the successful
completion of that call back you executed <code class="docutils literal notranslate"><span class="pre">schedule_callback</span></code> in. The function or method should not
take any arguments. After the the call back that was registered returns it must be registered again
in the next parent call back. On any error of the parent call back the registered call back will
not be called and must be registered again. Here’s how to use this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">some_function_or_method_that_takes_a_long_time_to_execute</span><span class="p">():</span>
   <span class="o">&lt;</span><span class="n">do</span> <span class="n">stuff</span><span class="o">&gt;</span>

<span class="k">def</span> <span class="nf">normal_rpc_call_back</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
   <span class="o">&lt;</span><span class="n">process</span> <span class="n">data</span><span class="o">&gt;</span>
   <span class="n">interface</span><span class="o">.</span><span class="n">schedule_callback</span><span class="p">(</span><span class="n">some_function_or_method_that_takes_a_long_time_to_execute</span><span class="p">)</span>
   <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>

<span class="n">interface</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="n">normal_rpc_call_back</span><span class="p">)</span>

<span class="n">interface</span><span class="o">.</span><span class="n">loop</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">schedule_callback</span></code> in particular allows you to use the <code class="docutils literal notranslate"><span class="pre">get_bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">put_bytes</span></code> methods for
cut-through data transfer between one device and another without the cost of packetization which
limits the size of the data moved inside the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library without running out of memory on the
OpenMV Cam.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">setup_loop_callback(cb):</code></dt>
<dd><p>The loop call back is called every loop iteration of <code class="docutils literal notranslate"><span class="pre">rpc_slave.loop()</span></code>. Unlike the <code class="docutils literal notranslate"><span class="pre">rpc.schedule_callback()</span></code> call
back this call back stays registered after being registered once. You can use the loop call back to
blink an activity LED or something like that. You should not use the loop call back to execute any
blocking code as this will get in the way of polling for communication from the master.
Additionally, the loop call back will be called at a variable rate depending on when and what call
backs the master is trying to execute. Given this, the loop call back is not suitable for any
method that needs to be executed at a fixed frequency.</p>
<p>On the OpenMV Cam, if you need to execute something at a fixed frequency, you should setup a timer
before executing <code class="docutils literal notranslate"><span class="pre">rpc_slave.loop()</span></code> and use a timer interrupt based callback to execute some function or method
at a fixed frequency. Please see how to Write Interrupt Handlers for more information. Note: The
<a class="reference internal" href="mutex.html#mutex.Mutex" title="mutex.Mutex"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Mutex</span></code></a> library is installed on your OpenMV Cam along with the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library.</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">loop(recv_timeout=1000, send_timeout=1000):</code></dt>
<dd><p>Starts execution of the <code class="docutils literal notranslate"><span class="pre">rpc</span></code> library on the slave to receive data. This method does not return
(except via an exception from a call back). You should register all call backs first before
executing this method. However, it is possible to register new call backs inside of a call back
previously being registered that is executing.</p>
<p><code class="docutils literal notranslate"><span class="pre">recv_timeout</span></code> defines how long to wait to receive a command from the master device before trying
again. <code class="docutils literal notranslate"><span class="pre">send_timeout</span></code> defines how long the slave will wait for the master to receive the call back
response before going back to trying to receive. The loop call back will be executed before trying
to receive again.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="class-rpc-can-master-can-master-interface">
<h2>class rpc_can_master - CAN Master Interface<a class="headerlink" href="#class-rpc-can-master-can-master-interface" title="Permalink to this headline">¶</a></h2>
<p>Control another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over CAN.</p>
<div class="section" id="id3">
<h3>Constructors<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<code class="sig-name descname">rpc_can_master(message_if=0x7FF, bit_rate=250000, sample_point=75, can_bus=2):</code></dt>
<dd><p>Creates a CAN <code class="docutils literal notranslate"><span class="pre">rpc</span></code> master. This interface can move up to 1 Mb/s.</p>
<ul class="simple">
<li><p>message_id - CAN message to use for data transport on the can bus (11-bit).</p></li>
<li><p>bit_rate - CAN bit rate.</p></li>
<li><p>sample_point - Tseg1/Tseg2 ratio. Typically 75%. (50.0, 62.5, 75, 87.5, etc.)</p></li>
<li><p>can_bus - CAN Bus number to use</p></li>
</ul>
<p>NOTE: Master and slave message ids and can bit rates must match. Connect master can high to slave
can high and master can low to slave can lo. The can bus must be terminated with 120 ohms.</p>
</dd></dl>

</div>
</div>
<div class="section" id="class-rpc-can-slave-can-slave-interface">
<h2>class rpc_can_slave - CAN Slave Interface<a class="headerlink" href="#class-rpc-can-slave-can-slave-interface" title="Permalink to this headline">¶</a></h2>
<p>Be controlled by another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over CAN.</p>
<div class="section" id="id4">
<h3>Constructors<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<code class="sig-name descname">rpc_can_slave(message_id=0x7FF, bit_rate=250000, sample_point=75, can_bus=2):</code></dt>
<dd><p>Creates a CAN <code class="docutils literal notranslate"><span class="pre">rpc</span></code> slave. This interface can move up to 1 Mb/s.</p>
<ul class="simple">
<li><p>message_id - CAN message to use for data transport on the can bus (11-bit).</p></li>
<li><p>bit_rate - CAN bit rate.</p></li>
<li><p>sample_point - Tseg1/Tseg2 ratio. Typically 75%. (50.0, 62.5, 75, 87.5, etc.)</p></li>
<li><p>can_bus - CAN Bus number to use</p></li>
</ul>
<p>NOTE: Master and slave message ids and can bit rates must match. Connect master can high to slave
can high and master can low to slave can lo. The can bus must be terminated with 120 ohms.</p>
</dd></dl>

</div>
</div>
<div class="section" id="class-rpc-i2c-master-i2c-master-interface">
<h2>class rpc_i2c_master - I2C Master Interface<a class="headerlink" href="#class-rpc-i2c-master-i2c-master-interface" title="Permalink to this headline">¶</a></h2>
<p>Control another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over I2C.</p>
<div class="section" id="id5">
<h3>Constructors<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="rpc.rpc_i2c_master">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_i2c_master</code><span class="sig-paren">(</span><em class="sig-param">slave_addr=0x12</em>, <em class="sig-param">rate=100000</em>, <em class="sig-param">i2c_bus=2</em><span class="sig-paren">)</span><a class="headerlink" href="#rpc.rpc_i2c_master" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a I2C <code class="docutils literal notranslate"><span class="pre">rpc</span></code> master. This interface can move up to 1 Mb/s.</p>
<ul class="simple">
<li><p>slave_addr - I2C address.</p></li>
<li><p>rate - I2C Bus Clock Frequency.</p></li>
<li><p>i2c_bus - I2C bus number to use.</p></li>
</ul>
<p>NOTE: Master and slave addresses must match. Connect master scl to slave scl and master sda
to slave sda. You must use external pull ups. Finally, both devices must share a ground.</p>
</dd></dl>

</div>
</div>
<div class="section" id="class-rpc-i2c-slave-i2c-slave-interface">
<h2>class rpc_i2c_slave - I2C Slave Interface<a class="headerlink" href="#class-rpc-i2c-slave-i2c-slave-interface" title="Permalink to this headline">¶</a></h2>
<p>Be controlled by another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over I2C.</p>
<div class="section" id="id6">
<h3>Constructors<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="rpc.rpc_i2c_slave">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_i2c_slave</code><span class="sig-paren">(</span><em class="sig-param">slave_addr=0x12</em>, <em class="sig-param">i2c_bus=2</em><span class="sig-paren">)</span><a class="headerlink" href="#rpc.rpc_i2c_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a I2C <code class="docutils literal notranslate"><span class="pre">rpc</span></code> slave. This interface can move up to 1 Mb/s.</p>
<ul class="simple">
<li><p>slave_addr - I2C address.</p></li>
<li><p>i2c_bus - I2C bus number to use.</p></li>
</ul>
<p>NOTE: Master and slave addresses must match. Connect master scl to slave scl and master sda
to slave sda. You must use external pull ups. Finally, both devices must share a ground.</p>
</dd></dl>

</div>
</div>
<div class="section" id="class-rpc-spi-master-spi-master-interface">
<h2>class rpc_spi_master - SPI Master Interface<a class="headerlink" href="#class-rpc-spi-master-spi-master-interface" title="Permalink to this headline">¶</a></h2>
<p>Control another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over SPI.</p>
<div class="section" id="id7">
<h3>Constructors<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="rpc.rpc_spi_master">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_spi_master</code><span class="sig-paren">(</span><em class="sig-param">cs_pin=&quot;P3&quot;</em>, <em class="sig-param">freq=10000000</em>, <em class="sig-param">clk_polarity=1</em>, <em class="sig-param">clk_phase=0</em>, <em class="sig-param">spi_bus=2</em><span class="sig-paren">)</span><a class="headerlink" href="#rpc.rpc_spi_master" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a SPI <code class="docutils literal notranslate"><span class="pre">rpc</span></code> master. This interface can move up to 80 Mb/s.</p>
<ul class="simple">
<li><p>cs_pin - Slave Select Pin.</p></li>
<li><p>freq - SPI Bus Clock Frequency.</p></li>
<li><p>clk_polarity - Idle clock level (0 or 1).</p></li>
<li><p>clk_phase - Sample data on the first (0) or second edge (1) of the clock.</p></li>
<li><p>spi_bus - SPI bus number to use.</p></li>
</ul>
<p>NOTE: Master and slave settings much match. Connect CS, SCLK, MOSI, MISO to CS, SCLK, MOSI, MISO.
Finally, both devices must share a common ground.</p>
</dd></dl>

</div>
</div>
<div class="section" id="class-rpc-spi-slave-spi-slave-interface">
<h2>class rpc_spi_slave - SPI Slave Interface<a class="headerlink" href="#class-rpc-spi-slave-spi-slave-interface" title="Permalink to this headline">¶</a></h2>
<p>Be controlled by another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over SPI.</p>
<dl class="class">
<dt id="rpc.rpc_spi_slave">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_spi_slave</code><span class="sig-paren">(</span><em class="sig-param">cs_pin=&quot;P3&quot;</em>, <em class="sig-param">clk_polarity=1</em>, <em class="sig-param">clk_phase=0</em>, <em class="sig-param">spi_bus=2</em><span class="sig-paren">)</span><a class="headerlink" href="#rpc.rpc_spi_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a SPI <code class="docutils literal notranslate"><span class="pre">rpc</span></code> slave. This interface can move up to 80 Mb/s.</p>
<ul class="simple">
<li><p>cs_pin - Slave Select Pin.</p></li>
<li><p>clk_polarity - Idle clock level (0 or 1).</p></li>
<li><p>clk_phase - Sample data on the first (0) or second edge (1) of the clock.</p></li>
<li><p>spi_bus - SPI bus number to use.</p></li>
</ul>
<p>NOTE: Master and slave settings much match. Connect CS, SCLK, MOSI, MISO to CS, SCLK, MOSI, MISO.
Finally, both devices must share a common ground.</p>
</dd></dl>

</div>
<div class="section" id="class-rpc-uart-master-uart-master-interface">
<h2>class rpc_uart_master - UART Master Interface<a class="headerlink" href="#class-rpc-uart-master-uart-master-interface" title="Permalink to this headline">¶</a></h2>
<p>Control another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over Async Serial (UART).</p>
<dl class="class">
<dt id="rpc.rpc_uart_master">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_uart_master</code><span class="sig-paren">(</span><em class="sig-param">baudrate=115200</em>, <em class="sig-param">uart_port=3</em><span class="sig-paren">)</span><a class="headerlink" href="#rpc.rpc_uart_master" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a UART <code class="docutils literal notranslate"><span class="pre">rpc</span></code> master. This interface can move up to 7.5 Mb/s.</p>
<ul class="simple">
<li><p>baudrate - Serial Baudrate.</p></li>
<li><p>uart_port - UART port to use.</p></li>
</ul>
<p>NOTE: Master and slave baud rates must match. Connect master tx to slave rx and master rx to
slave tx. Finally, both devices must share a common ground.</p>
</dd></dl>

</div>
<div class="section" id="class-rpc-uart-slave-uart-slave-interface">
<h2>class rpc_uart_slave - UART Slave Interface<a class="headerlink" href="#class-rpc-uart-slave-uart-slave-interface" title="Permalink to this headline">¶</a></h2>
<p>Be controlled by another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over Async Serial (UART).</p>
<dl class="class">
<dt id="rpc.rpc_uart_slave">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_uart_slave</code><span class="sig-paren">(</span><em class="sig-param">baudrate=115200</em>, <em class="sig-param">uart_port=3</em><span class="sig-paren">)</span><a class="headerlink" href="#rpc.rpc_uart_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a UART <code class="docutils literal notranslate"><span class="pre">rpc</span></code> slave. This interface can move up to 7.5 Mb/s.</p>
<ul class="simple">
<li><p>baudrate - Serial Baudrate.</p></li>
<li><p>uart_port - UART port to use.</p></li>
</ul>
<p>NOTE: Master and slave baud rates must match. Connect master tx to slave rx and master rx to
slave tx. Finally, both devices must share a common ground.</p>
</dd></dl>

</div>
<div class="section" id="class-rpc-usb-vcp-master-usb-vcp-master-interface">
<h2>class rpc_usb_vcp_master - USB VCP Master Interface<a class="headerlink" href="#class-rpc-usb-vcp-master-usb-vcp-master-interface" title="Permalink to this headline">¶</a></h2>
<p>Control another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over a USB Virtual COM Port.</p>
<dl class="class">
<dt id="rpc.rpc_usb_vcp_master">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_usb_vcp_master</code><a class="headerlink" href="#rpc.rpc_usb_vcp_master" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a USB VCP <code class="docutils literal notranslate"><span class="pre">rpc</span></code> master. This interface can move data at the USB speed.</p>
</dd></dl>

</div>
<div class="section" id="class-rpc-usb-vcp-slave-usb-vcp-slave-interface">
<h2>class rpc_usb_vcp_slave - USB VCP Slave Interface<a class="headerlink" href="#class-rpc-usb-vcp-slave-usb-vcp-slave-interface" title="Permalink to this headline">¶</a></h2>
<p>Be controlled by another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over a USB Virtual COM Port.</p>
<dl class="class">
<dt id="rpc.rpc_usb_vcp_slave">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_usb_vcp_slave</code><a class="headerlink" href="#rpc.rpc_usb_vcp_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a USB VCP <code class="docutils literal notranslate"><span class="pre">rpc</span></code> slave. This interface can move data at the USB speed.</p>
</dd></dl>

</div>
<div class="section" id="class-rpc-network-master-network-master-interface">
<h2>class rpc_network_master - Network Master Interface<a class="headerlink" href="#class-rpc-network-master-network-master-interface" title="Permalink to this headline">¶</a></h2>
<p>Control another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device over a network.</p>
<dl class="class">
<dt id="rpc.rpc_network_master">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_network_master</code><span class="sig-paren">(</span><em class="sig-param">network_if</em>, <em class="sig-param">port=0x1DBA</em><span class="sig-paren">)</span><a class="headerlink" href="#rpc.rpc_network_master" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Network <code class="docutils literal notranslate"><span class="pre">rpc</span></code> master.</p>
<ul class="simple">
<li><p>network_if - Network interface created from <code class="docutils literal notranslate"><span class="pre">network.LAN()</span></code>, <code class="docutils literal notranslate"><span class="pre">network.WLAN()</span></code>, or etc.</p></li>
<li><p>port - Port to route traffic to.</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="class-rpc-network-slave-network-slave-interface">
<h2>class rpc_network_slave - Network Slave Interface<a class="headerlink" href="#class-rpc-network-slave-network-slave-interface" title="Permalink to this headline">¶</a></h2>
<p>Be controlled by another <code class="docutils literal notranslate"><span class="pre">rpc</span></code> device a network.</p>
<dl class="class">
<dt id="rpc.rpc_network_slave">
<em class="property">class </em><code class="sig-prename descclassname">rpc.</code><code class="sig-name descname">rpc_network_slave</code><span class="sig-paren">(</span><em class="sig-param">network_if</em>, <em class="sig-param">port=0x1DBA</em><span class="sig-paren">)</span><a class="headerlink" href="#rpc.rpc_network_slave" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Network <code class="docutils literal notranslate"><span class="pre">rpc</span></code> slave.</p>
<ul class="simple">
<li><p>network_if - Network interface created from <code class="docutils literal notranslate"><span class="pre">network.LAN()</span></code>, <code class="docutils literal notranslate"><span class="pre">network.WLAN()</span></code>, or etc.</p></li>
<li><p>port - Port to route traffic to.</p></li>
</ul>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/web-logo-sticky.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rpc</span></code> — rpc library</a><ul>
<li><a class="reference internal" href="#how-to-use-the-library">How to use the Library</a></li>
<li><a class="reference internal" href="#class-rpc-rpc-virtual-class">class rpc - rpc virtual class</a><ul>
<li><a class="reference internal" href="#constructors">Constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-rpc-master-rpc-master-virtual-class">class rpc_master - rpc_master virtual class</a><ul>
<li><a class="reference internal" href="#id1">Constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-rpc-slave-rpc-slave-virtual-class">class rpc_slave - rpc_slave virtual class</a><ul>
<li><a class="reference internal" href="#id2">Constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-rpc-can-master-can-master-interface">class rpc_can_master - CAN Master Interface</a><ul>
<li><a class="reference internal" href="#id3">Constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-rpc-can-slave-can-slave-interface">class rpc_can_slave - CAN Slave Interface</a><ul>
<li><a class="reference internal" href="#id4">Constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-rpc-i2c-master-i2c-master-interface">class rpc_i2c_master - I2C Master Interface</a><ul>
<li><a class="reference internal" href="#id5">Constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-rpc-i2c-slave-i2c-slave-interface">class rpc_i2c_slave - I2C Slave Interface</a><ul>
<li><a class="reference internal" href="#id6">Constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-rpc-spi-master-spi-master-interface">class rpc_spi_master - SPI Master Interface</a><ul>
<li><a class="reference internal" href="#id7">Constructors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-rpc-spi-slave-spi-slave-interface">class rpc_spi_slave - SPI Slave Interface</a></li>
<li><a class="reference internal" href="#class-rpc-uart-master-uart-master-interface">class rpc_uart_master - UART Master Interface</a></li>
<li><a class="reference internal" href="#class-rpc-uart-slave-uart-slave-interface">class rpc_uart_slave - UART Slave Interface</a></li>
<li><a class="reference internal" href="#class-rpc-usb-vcp-master-usb-vcp-master-interface">class rpc_usb_vcp_master - USB VCP Master Interface</a></li>
<li><a class="reference internal" href="#class-rpc-usb-vcp-slave-usb-vcp-slave-interface">class rpc_usb_vcp_slave - USB VCP Slave Interface</a></li>
<li><a class="reference internal" href="#class-rpc-network-master-network-master-interface">class rpc_network_master - Network Master Interface</a></li>
<li><a class="reference internal" href="#class-rpc-network-slave-network-slave-interface">class rpc_network_slave - Network Slave Interface</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="omv.imu.html"
                        title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">imu</span></code> — imu sensor</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="omv.rtsp.html"
                        title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rtsp</span></code> — rtsp library</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/library/omv.rpc.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="omv.rtsp.html" title="rtsp — rtsp library"
             >next</a> |</li>
        <li class="right" >
          <a href="omv.imu.html" title="imu — imu sensor"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MicroPython 1.19 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >MicroPython libraries</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright - The MicroPython Documentation is Copyright © 2014-2023, Damien P. George, Paul Sokolovsky, and contributors.
      Last updated on 02 May 2023.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  </body>
</html>