<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Writing interrupt handlers &mdash; MicroPython 1.20 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=d5a28fe3" />
      <link rel="stylesheet" href="../_static/customstyle.css" type="text/css" />

  
    <link rel="shortcut icon" href="../_static/openmv.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=6b422e2e"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Maximising MicroPython speed" href="speed_python.html" />
    <link rel="prev" title="MicroPython .mpy files" href="mpyfiles.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MicroPython
              <img src="../_static/web-logo-sticky.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.20
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../library/index.html">MicroPython libraries</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">MicroPython language and implementation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l2"><a class="reference internal" href="repl.html">The MicroPython Interactive Interpreter Mode (aka REPL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpremote.html">MicroPython remote control: mpremote</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpyfiles.html">MicroPython .mpy files</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Writing interrupt handlers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tips-and-recommended-practices">Tips and recommended practices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#micropython-issues">MicroPython issues</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-emergency-exception-buffer">The emergency exception buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simplicity">Simplicity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#communication-between-an-isr-and-the-main-program">Communication between an ISR and the main program</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-use-of-object-methods-as-callbacks">The use of object methods as callbacks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creation-of-python-objects">Creation of Python objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#use-of-python-objects">Use of Python objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overcoming-the-float-limitation">Overcoming the float limitation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-micropython-schedule">Using micropython.schedule</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exceptions">Exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interfacing-to-uasyncio">Interfacing to uasyncio</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-issues">General issues</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-handler-design">Interrupt handler design</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reentrancy">Reentrancy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#critical-sections">Critical sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupts-and-the-repl">Interrupts and the REPL</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="speed_python.html">Maximising MicroPython speed</a></li>
<li class="toctree-l2"><a class="reference internal" href="constrained.html">MicroPython on microcontrollers</a></li>
<li class="toctree-l2"><a class="reference internal" href="manifest.html">MicroPython manifest files</a></li>
<li class="toctree-l2"><a class="reference internal" href="packages.html">Package management</a></li>
<li class="toctree-l2"><a class="reference internal" href="asm_thumb2_index.html">Inline assembler for Thumb2 architectures</a></li>
<li class="toctree-l2"><a class="reference internal" href="filesystem.html">Working with filesystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="pyboard.py.html">The pyboard.py tool</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../genrst/index.html">MicroPython differences from CPython</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">MicroPython license information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openmvcam/quickref.html">Quick reference for the openmvcam</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MicroPython</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">MicroPython language and implementation</a></li>
      <li class="breadcrumb-item active">Writing interrupt handlers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/reference/isr_rules.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="writing-interrupt-handlers">
<span id="isr-rules"></span><h1>Writing interrupt handlers<a class="headerlink" href="#writing-interrupt-handlers" title="Permalink to this heading">¶</a></h1>
<p>On suitable hardware MicroPython offers the ability to write interrupt handlers in Python. Interrupt handlers
- also known as interrupt service routines (ISR’s) - are defined as callback functions. These are executed
in response to an event such as a timer trigger or a voltage change on a pin. Such events can occur at any point
in the execution of the program code. This carries significant consequences, some specific to the MicroPython
language. Others are common to all systems capable of responding to real time events. This document covers
the language specific issues first, followed by a brief introduction to real time programming for those new to it.</p>
<p>This introduction uses vague terms like “slow” or “as fast as possible”. This is deliberate, as speeds are
application dependent. Acceptable durations for an ISR are dependent on the rate at which interrupts occur,
the nature of the main program, and the presence of other concurrent events.</p>
<section id="tips-and-recommended-practices">
<h2>Tips and recommended practices<a class="headerlink" href="#tips-and-recommended-practices" title="Permalink to this heading">¶</a></h2>
<p>This summarises the points detailed below and lists the principal recommendations for interrupt handler code.</p>
<ul class="simple">
<li><p>Keep the code as short and simple as possible.</p></li>
<li><p>Avoid memory allocation: no appending to lists or insertion into dictionaries, no floating point.</p></li>
<li><p>Consider using <code class="docutils literal notranslate"><span class="pre">micropython.schedule</span></code> to work around the above constraint.</p></li>
<li><p>Where an ISR returns multiple bytes use a pre-allocated <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>. If multiple integers are to be
shared between an ISR and the main program consider an array (<code class="docutils literal notranslate"><span class="pre">array.array</span></code>).</p></li>
<li><p>Where data is shared between the main program and an ISR, consider disabling interrupts prior to accessing
the data in the main program and re-enabling them immediately afterwards (see Critical Sections).</p></li>
<li><p>Allocate an emergency exception buffer (see below).</p></li>
</ul>
</section>
<section id="micropython-issues">
<h2>MicroPython issues<a class="headerlink" href="#micropython-issues" title="Permalink to this heading">¶</a></h2>
<section id="the-emergency-exception-buffer">
<h3>The emergency exception buffer<a class="headerlink" href="#the-emergency-exception-buffer" title="Permalink to this heading">¶</a></h3>
<p>If an error occurs in an ISR, MicroPython is unable to produce an error report unless a special buffer is created
for the purpose. Debugging is simplified if the following code is included in any program using interrupts.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">micropython</span>
<span class="n">micropython</span><span class="o">.</span><span class="n">alloc_emergency_exception_buf</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>The emergency exception buffer can only hold one exception stack trace. This means that if a second exception is
thrown during the handling of an exception while the heap is locked, that second exception’s stack trace will
replace the original one - even if the second exception is cleanly handled. This can lead to confusing exception
messages if the buffer is later printed.</p>
</section>
<section id="simplicity">
<h3>Simplicity<a class="headerlink" href="#simplicity" title="Permalink to this heading">¶</a></h3>
<p>For a variety of reasons it is important to keep ISR code as short and simple as possible. It should do only what
has to be done immediately after the event which caused it: operations which can be deferred should be delegated
to the main program loop. Typically an ISR will deal with the hardware device which caused the interrupt, making
it ready for the next interrupt to occur. It will communicate with the main loop by updating shared data to indicate
that the interrupt has occurred, and it will return. An ISR should return control to the main loop as quickly
as possible. This is not a specific MicroPython issue so is covered in more detail <a class="reference internal" href="#isr"><span class="std std-ref">below</span></a>.</p>
</section>
<section id="communication-between-an-isr-and-the-main-program">
<h3>Communication between an ISR and the main program<a class="headerlink" href="#communication-between-an-isr-and-the-main-program" title="Permalink to this heading">¶</a></h3>
<p>Normally an ISR needs to communicate with the main program. The simplest means of doing this is via one or more
shared data objects, either declared as global or shared via a class (see below). There are various restrictions
and hazards around doing this, which are covered in more detail below. Integers, <code class="docutils literal notranslate"><span class="pre">bytes</span></code> and <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> objects
are commonly used for this purpose along with arrays (from the array module) which can store various data types.</p>
</section>
<section id="the-use-of-object-methods-as-callbacks">
<h3>The use of object methods as callbacks<a class="headerlink" href="#the-use-of-object-methods-as-callbacks" title="Permalink to this heading">¶</a></h3>
<p>MicroPython supports this powerful technique which enables an ISR to share instance variables with the underlying
code. It also enables a class implementing a device driver to support multiple device instances. The following
example causes two LED’s to flash at different rates.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyb</span><span class="o">,</span> <span class="nn">micropython</span>
<span class="n">micropython</span><span class="o">.</span><span class="n">alloc_emergency_exception_buf</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timer</span><span class="p">,</span> <span class="n">led</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">led</span> <span class="o">=</span> <span class="n">led</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cb</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tim</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">led</span><span class="o">.</span><span class="n">toggle</span><span class="p">()</span>

<span class="n">red</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">pyb</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">pyb</span><span class="o">.</span><span class="n">LED</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">green</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="n">pyb</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mf">0.8</span><span class="p">),</span> <span class="n">pyb</span><span class="o">.</span><span class="n">LED</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>In this example the <code class="docutils literal notranslate"><span class="pre">red</span></code> instance associates timer 4 with LED 1: when a timer 4 interrupt occurs <code class="docutils literal notranslate"><span class="pre">red.cb()</span></code>
is called causing LED 1 to change state. The <code class="docutils literal notranslate"><span class="pre">green</span></code> instance operates similarly: a timer 2 interrupt
results in the execution of <code class="docutils literal notranslate"><span class="pre">green.cb()</span></code> and toggles LED 2. The use of instance methods confers two
benefits. Firstly a single class enables code to be shared between multiple hardware instances. Secondly, as
a bound method the callback function’s first argument is <code class="docutils literal notranslate"><span class="pre">self</span></code>. This enables the callback to access instance
data and to save state between successive calls. For example, if the class above had a variable <code class="docutils literal notranslate"><span class="pre">self.count</span></code>
set to zero in the constructor, <code class="docutils literal notranslate"><span class="pre">cb()</span></code> could increment the counter. The <code class="docutils literal notranslate"><span class="pre">red</span></code> and <code class="docutils literal notranslate"><span class="pre">green</span></code> instances would
then maintain independent counts of the number of times each LED had changed state.</p>
</section>
<section id="creation-of-python-objects">
<h3>Creation of Python objects<a class="headerlink" href="#creation-of-python-objects" title="Permalink to this heading">¶</a></h3>
<p>ISR’s cannot create instances of Python objects. This is because MicroPython needs to allocate memory for the
object from a store of free memory block called the heap. This is not permitted in an interrupt handler because
heap allocation is not re-entrant. In other words the interrupt might occur when the main program is part way
through performing an allocation - to maintain the integrity of the heap the interpreter disallows memory
allocations in ISR code.</p>
<p>A consequence of this is that ISR’s can’t use floating point arithmetic; this is because floats are Python objects. Similarly
an ISR can’t append an item to a list. In practice it can be hard to determine exactly which code constructs will
attempt to perform memory allocation and provoke an error message: another reason for keeping ISR code short and simple.</p>
<p>One way to avoid this issue is for the ISR to use pre-allocated buffers. For example a class constructor
creates a <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> instance and a boolean flag. The ISR method assigns data to locations in the buffer and sets
the flag. The memory allocation occurs in the main program code when the object is instantiated rather than in the ISR.</p>
<p>The MicroPython library I/O methods usually provide an option to use a pre-allocated buffer. For
example <code class="docutils literal notranslate"><span class="pre">pyb.i2c.recv()</span></code> can accept a mutable buffer as its first argument: this enables its use in an ISR.</p>
<p>A means of creating an object without employing a class or globals is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_volume</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">buf</span><span class="o">=</span><span class="nb">bytearray</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
    <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xa5</span>
    <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
    <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x5a</span>
    <span class="k">return</span> <span class="n">buf</span>
</pre></div>
</div>
<p>The compiler instantiates the default <code class="docutils literal notranslate"><span class="pre">buf</span></code> argument when the function is
loaded for the first time (usually when the module it’s in is imported).</p>
<p>An instance of object creation occurs when a reference to a bound method is
created. This means that an ISR cannot pass a bound method to a function. One
solution is to create a reference to the bound method in the class constructor
and to pass that reference in the ISR. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bar_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bar</span>  <span class="c1"># Allocation occurs here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="n">tim</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">tim</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">tim</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cb</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*=</span> <span class="mf">1.2</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="c1"># Passing self.bar would cause allocation.</span>
        <span class="n">micropython</span><span class="o">.</span><span class="n">schedule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bar_ref</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Other techniques are to define and instantiate the method in the constructor
or to pass <code class="xref py py-meth docutils literal notranslate"><span class="pre">Foo.bar()</span></code> with the argument <em>self</em>.</p>
</section>
<section id="use-of-python-objects">
<h3>Use of Python objects<a class="headerlink" href="#use-of-python-objects" title="Permalink to this heading">¶</a></h3>
<p>A further restriction on objects arises because of the way Python works. When an <code class="docutils literal notranslate"><span class="pre">import</span></code> statement is executed the
Python code is compiled to bytecode, with one line of code typically mapping to multiple bytecodes. When the code
runs the interpreter reads each bytecode and executes it as a series of machine code instructions. Given that an
interrupt can occur at any time between machine code instructions, the original line of Python code may be only
partially executed. Consequently a Python object such as a set, list or dictionary modified in the main loop
may lack internal consistency at the moment the interrupt occurs.</p>
<p>A typical outcome is as follows. On rare occasions the ISR will run at the precise moment in time when the object
is partially updated. When the ISR tries to read the object, a crash results. Because such problems typically occur
on rare, random occasions they can be hard to diagnose. There are ways to circumvent this issue, described in
<a class="reference internal" href="#critical"><span class="std std-ref">Critical Sections</span></a> below.</p>
<p>It is important to be clear about what constitutes the modification of an object. An alteration to a built-in type
such as a dictionary is problematic. Altering the contents of an array or bytearray is not. This is because bytes
or words are written as a single machine code instruction which is not interruptible: in the parlance of real time
programming the write is atomic. A user defined object might instantiate an integer, array or bytearray. It is valid
for both the main loop and the ISR to alter the contents of these.</p>
<p>MicroPython supports integers of arbitrary precision. Values between 2**30 -1 and -2**30 will be stored in
a single machine word. Larger values are stored as Python objects. Consequently changes to long integers cannot
be considered atomic. The use of long integers in ISR’s is unsafe because memory allocation may be
attempted as the variable’s value changes.</p>
</section>
<section id="overcoming-the-float-limitation">
<h3>Overcoming the float limitation<a class="headerlink" href="#overcoming-the-float-limitation" title="Permalink to this heading">¶</a></h3>
<p>In general it is best to avoid using floats in ISR code: hardware devices normally handle integers and conversion
to floats is normally done in the main loop. However there are a few DSP algorithms which require floating point.
On platforms with hardware floating point (such as the Pyboard) the inline ARM Thumb assembler can be used to work
round this limitation. This is because the processor stores float values in a machine word; values can be shared
between the ISR and main program code via an array of floats.</p>
</section>
<section id="using-micropython-schedule">
<h3>Using micropython.schedule<a class="headerlink" href="#using-micropython-schedule" title="Permalink to this heading">¶</a></h3>
<p>This function enables an ISR to schedule a callback for execution “very soon”. The callback is queued for
execution which will take place at a time when the heap is not locked. Hence it can create Python objects
and use floats. The callback is also guaranteed to run at a time when the main program has completed any
update of Python objects, so the callback will not encounter partially updated objects.</p>
<p>Typical usage is to handle sensor hardware. The ISR acquires data from the hardware and enables it to
issue a further interrupt. It then schedules a callback to process the data.</p>
<p>Scheduled callbacks should comply with the principles of interrupt handler design outlined below. This is to
avoid problems resulting from I/O activity and the modification of shared data which can arise in any code
which pre-empts the main program loop.</p>
<p>Execution time needs to be considered in relation to the frequency with which interrupts can occur. If an
interrupt occurs while the previous callback is executing, a further instance of the callback will be queued
for execution; this will run after the current instance has completed. A sustained high interrupt repetition
rate therefore carries a risk of unconstrained queue growth and eventual failure with a <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code>.</p>
<p>If the callback to be passed to <a class="reference internal" href="../library/micropython.html#micropython.schedule" title="micropython.schedule"><code class="xref any py py-func docutils literal notranslate"><span class="pre">schedule()</span></code></a> is a bound method, consider the
note in “Creation of Python objects”.</p>
</section>
</section>
<section id="exceptions">
<h2>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this heading">¶</a></h2>
<p>If an ISR raises an exception it will not propagate to the main loop. The interrupt will be disabled unless the
exception is handled by the ISR code.</p>
</section>
<section id="interfacing-to-uasyncio">
<h2>Interfacing to uasyncio<a class="headerlink" href="#interfacing-to-uasyncio" title="Permalink to this heading">¶</a></h2>
<p>When an ISR runs it can preempt the <a class="reference internal" href="../library/uasyncio.html#module-uasyncio" title="uasyncio: asynchronous I/O scheduler for writing concurrent code"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">uasyncio</span></code></a> scheduler. If the ISR performs a <a class="reference internal" href="../library/uasyncio.html#module-uasyncio" title="uasyncio: asynchronous I/O scheduler for writing concurrent code"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">uasyncio</span></code></a>
operation the scheduler’s operation can be disrupted. This applies whether the interrupt is hard
or soft and also applies if the ISR has passed execution to another function via
<a class="reference internal" href="../library/micropython.html#micropython.schedule" title="micropython.schedule"><code class="xref any py py-func docutils literal notranslate"><span class="pre">micropython.schedule</span></code></a>. In particular creating or cancelling tasks is invalid in an ISR context.
The safe way to interact with <a class="reference internal" href="../library/uasyncio.html#module-uasyncio" title="uasyncio: asynchronous I/O scheduler for writing concurrent code"><code class="xref any py py-mod docutils literal notranslate"><span class="pre">uasyncio</span></code></a> is to implement a coroutine with synchronisation performed by
<a class="reference internal" href="../library/uasyncio.html#uasyncio.ThreadSafeFlag" title="uasyncio.ThreadSafeFlag"><code class="xref any py py-class docutils literal notranslate"><span class="pre">uasyncio.ThreadSafeFlag</span></code></a>. The following fragment illustrates the creation of a task in response
to an interrupt:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tsf</span> <span class="o">=</span> <span class="n">uasyncio</span><span class="o">.</span><span class="n">ThreadSafeFlag</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">isr</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>  <span class="c1"># Interrupt handler</span>
    <span class="n">tsf</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">tsf</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="n">uasyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">bar</span><span class="p">())</span>
</pre></div>
</div>
<p>In this example there will be a variable amount of latency between the execution of the ISR and the execution
of <code class="docutils literal notranslate"><span class="pre">foo()</span></code>. This is inherent to cooperative scheduling. The maximum latency is application
and platform dependent but may typically be measured in tens of ms.</p>
</section>
<section id="general-issues">
<h2>General issues<a class="headerlink" href="#general-issues" title="Permalink to this heading">¶</a></h2>
<p>This is merely a brief introduction to the subject of real time programming. Beginners should note
that design errors in real time programs can lead to faults which are particularly hard to diagnose. This is because
they can occur rarely and at intervals which are essentially random. It is crucial to get the initial design right and
to anticipate issues before they arise. Both interrupt handlers and the main program need to be designed
with an appreciation of the following issues.</p>
<section id="interrupt-handler-design">
<span id="isr"></span><h3>Interrupt handler design<a class="headerlink" href="#interrupt-handler-design" title="Permalink to this heading">¶</a></h3>
<p>As mentioned above, ISR’s should be designed to be as simple as possible. They should always return in a short,
predictable period of time. This is important because when the ISR is running, the main loop is not: inevitably
the main loop experiences pauses in its execution at random points in the code. Such pauses can be a source of hard
to diagnose bugs particularly if their duration is long or variable. In order to understand the implications of
ISR run time, a basic grasp of interrupt priorities is required.</p>
<p>Interrupts are organised according to a priority scheme. ISR code may itself be interrupted by a higher priority
interrupt. This has implications if the two interrupts share data (see Critical Sections below). If such an interrupt
occurs it interposes a delay into the ISR code. If a lower priority interrupt occurs while the ISR is running, it
will be delayed until the ISR is complete: if the delay is too long, the lower priority interrupt may fail. A
further issue with slow ISR’s is the case where a second interrupt of the same type occurs during its execution.
The second interrupt will be handled on termination of the first. However if the rate of incoming interrupts
consistently exceeds the capacity of the ISR to service them the outcome will not be a happy one.</p>
<p>Consequently looping constructs should be avoided or minimised. I/O to devices other than to the interrupting device
should normally be avoided: I/O such as disk access, <code class="docutils literal notranslate"><span class="pre">print</span></code> statements and UART access is relatively slow, and
its duration may vary. A further issue here is that filesystem functions are not reentrant: using filesystem I/O
in an ISR and the main program would be hazardous. Crucially ISR code should not wait on an event. I/O is acceptable
if the code can be guaranteed to return in a predictable period, for example toggling a pin or LED. Accessing the
interrupting device via I2C or SPI may be necessary but the time taken for such accesses should be calculated or
measured and its impact on the application assessed.</p>
<p>There is usually a need to share data between the ISR and the main loop. This may be done either through global
variables or via class or instance variables. Variables are typically integer or boolean types, or integer or byte
arrays (a pre-allocated integer array offers faster access than a list). Where multiple values are modified by
the ISR it is necessary to consider the case where the interrupt occurs at a time when the main program has
accessed some, but not all, of the values. This can lead to inconsistencies.</p>
<p>Consider the following design. An ISR stores incoming data in a bytearray, then adds the number of bytes
received to an integer representing total bytes ready for processing. The main program reads the number of bytes,
processes the bytes, then clears down the number of bytes ready. This will work until an interrupt occurs just
after the main program has read the number of bytes. The ISR puts the added data into the buffer and updates
the number received, but the main program has already read the number, so processes the data originally received.
The newly arrived bytes are lost.</p>
<p>There are various ways of avoiding this hazard, the simplest being to use a circular buffer. If it is not possible
to use a structure with inherent thread safety other ways are described below.</p>
</section>
<section id="reentrancy">
<h3>Reentrancy<a class="headerlink" href="#reentrancy" title="Permalink to this heading">¶</a></h3>
<p>A potential hazard may occur if a function or method is shared between the main program and one or more ISR’s or
between multiple ISR’s. The issue here is that the function may itself be interrupted and a further instance of
that function run. If this is to occur, the function must be designed to be reentrant. How this is done is an
advanced topic beyond the scope of this tutorial.</p>
</section>
<section id="critical-sections">
<span id="critical"></span><h3>Critical sections<a class="headerlink" href="#critical-sections" title="Permalink to this heading">¶</a></h3>
<p>An example of a critical section of code is one which accesses more than one variable which can be affected by an ISR. If
the interrupt happens to occur between accesses to the individual variables, their values will be inconsistent. This is
an instance of a hazard known as a race condition: the ISR and the main program loop race to alter the variables. To
avoid inconsistency a means must be employed to ensure that the ISR does not alter the values for the duration of
the critical section. One way to achieve this is to issue <code class="docutils literal notranslate"><span class="pre">pyb.disable_irq()</span></code> before the start of the section, and
<code class="docutils literal notranslate"><span class="pre">pyb.enable_irq()</span></code> at the end. Here is an example of this approach:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyb</span><span class="o">,</span> <span class="nn">micropython</span><span class="o">,</span> <span class="nn">array</span>
<span class="n">micropython</span><span class="o">.</span><span class="n">alloc_emergency_exception_buf</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BoundsException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">ARRAYSIZE</span> <span class="o">=</span> <span class="n">const</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ARRAYSIZE</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">callback1</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">data</span><span class="p">,</span> <span class="n">index</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">rng</span><span class="p">()</span> <span class="c1"># simulate input</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">ARRAYSIZE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BoundsException</span><span class="p">(</span><span class="s1">&#39;Array bounds exceeded&#39;</span><span class="p">)</span>

<span class="n">tim4</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">callback1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">irq_state</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">disable_irq</span><span class="p">()</span> <span class="c1"># Start of critical section</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pyb</span><span class="o">.</span><span class="n">enable_irq</span><span class="p">(</span><span class="n">irq_state</span><span class="p">)</span> <span class="c1"># End of critical section</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;loop </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">loop</span><span class="p">))</span>
    <span class="n">pyb</span><span class="o">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">tim4</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>A critical section can comprise a single line of code and a single variable. Consider the following code fragment.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="nf">cb</span><span class="p">():</span> <span class="c1"># An interrupt callback</span>
    <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Code to set up the interrupt callback omitted</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>This example illustrates a subtle source of bugs. The line <code class="docutils literal notranslate"><span class="pre">count</span> <span class="pre">+=</span> <span class="pre">1</span></code> in the main loop carries a specific race
condition hazard known as a read-modify-write. This is a classic cause of bugs in real time systems. In the main loop
MicroPython reads the value of <code class="docutils literal notranslate"><span class="pre">count</span></code>, adds 1 to it, and writes it back. On rare occasions the  interrupt occurs
after the read and before the write. The interrupt modifies <code class="docutils literal notranslate"><span class="pre">count</span></code> but its change is overwritten by the main
loop when the ISR returns. In a real system this could lead to rare, unpredictable failures.</p>
<p>As mentioned above, care should be taken if an instance of a Python built in type is modified in the main code and
that instance is accessed in an ISR. The code performing the modification should be regarded as a critical
section to ensure that the instance is in a valid state when the ISR runs.</p>
<p>Particular care needs to be taken if a dataset is shared between different ISR’s. The hazard here is that the higher
priority interrupt may occur when the lower priority one has partially updated the shared data. Dealing with this
situation is an advanced topic beyond the scope of this introduction other than to note that mutex objects described
below can sometimes be used.</p>
<p>Disabling interrupts for the duration of a critical section is the usual and simplest way to proceed, but it disables
all interrupts rather than merely the one with the potential to cause problems. It is generally undesirable to disable
an interrupt for long. In the case of timer interrupts it introduces variability to the time when a callback occurs.
In the case of device interrupts, it can lead to the device being serviced too late with possible loss of data or
overrun errors in the device hardware. Like ISR’s, a critical section in the main code should have a short, predictable
duration.</p>
<p>An approach to dealing with critical sections which radically reduces the time for which interrupts are disabled is to
use an object termed a mutex (name derived from the notion of mutual exclusion). The main program locks the mutex
before running the critical section and unlocks it at the end. The ISR tests whether the mutex is locked. If it is,
it avoids the critical section and returns. The design challenge is defining what the ISR should do in the event
that access to the critical variables is denied. A simple example of a mutex may be found
<a class="reference external" href="https://github.com/peterhinch/micropython-samples.git">here</a>. Note that the mutex code does disable interrupts,
but only for the duration of eight machine instructions: the benefit of this approach is that other interrupts are
virtually unaffected.</p>
</section>
<section id="interrupts-and-the-repl">
<h3>Interrupts and the REPL<a class="headerlink" href="#interrupts-and-the-repl" title="Permalink to this heading">¶</a></h3>
<p>Interrupt handlers, such as those associated with timers, can continue to run
after a program terminates.  This may produce unexpected results where you might
have expected the object raising the callback to have gone out of scope.  For
example on the Pyboard:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">))</span>

<span class="n">bar</span><span class="p">()</span>
</pre></div>
</div>
<p>This continues to run until the timer is explicitly disabled or the board is
reset with <code class="docutils literal notranslate"><span class="pre">ctrl</span> <span class="pre">D</span></code>.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="mpyfiles.html" class="btn btn-neutral float-left" title="MicroPython .mpy files" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="speed_python.html" class="btn btn-neutral float-right" title="Maximising MicroPython speed" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright - The MicroPython Documentation is Copyright © 2014-2023, Damien P. George, Paul Sokolovsky, and contributors.
      <span class="lastupdated">Last updated on 01 Dec 2023.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Language and External Links</span>
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Language</dt>
      <dd>
        <a href="https://openmv.io">English</a>
      </dd>
      <dd>
        <a href="http://doc.singtown.cc">中文</a>
      </dd>
    </dl>
    <hr/>
    <dl>
      <dt>External links</dt>
      <dd>
        <a href="https://openmv.io">openmv.io</a>
      </dd>
      <dd>
        <a href="http://forums.openmv.io">forums.openmv.io</a>
      </dd>
      <dd>
        <a href="https://github.com/openmv/openmv">github.com/openmv/openmv</a>
      </dd>
      <dd>
        <a href="http://micropython.org">micropython.org</a>
      </dd>
      <dd>
        <a href="http://forum.micropython.org">forum.micropython.org</a>
      </dd>
      <dd>
        <a href="https://github.com/micropython/micropython">github.com/micropython/micropython</a>
      </dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>