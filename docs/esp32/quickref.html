<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quick reference for the ESP32 &mdash; MicroPython 1.22 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=d5a28fe3" />
      <link rel="stylesheet" href="../_static/customstyle.css" type="text/css" />

  
    <link rel="shortcut icon" href="../_static/openmv.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=f8c2205d"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MicroPython
              <img src="../_static/web-logo-sticky.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.22
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../library/index.html">MicroPython libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">MicroPython language and implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genrst/index.html">MicroPython differences from CPython</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">MicroPython license information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../openmvcam/quickref.html">Quick reference for the openmvcam</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MicroPython</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Quick reference for the ESP32</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/esp32/quickref.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quick-reference-for-the-esp32">
<span id="esp32-quickref"></span><h1>Quick reference for the ESP32<a class="headerlink" href="#quick-reference-for-the-esp32" title="Permalink to this heading">¶</a></h1>
<a class="reference internal image-reference" href="../_images/esp32.jpg"><img alt="ESP32 board" src="../_images/esp32.jpg" style="width: 640px;" /></a>
<p>The Espressif ESP32 Development Board (image attribution: Adafruit).</p>
<p>Below is a quick reference for ESP32-based boards.  If it is your first time
working with this board it may be useful to get an overview of the microcontroller:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="general.html">General information about the ESP32 port</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/index.html">MicroPython tutorial for ESP32</a></li>
</ul>
</div>
<section id="installing-micropython">
<h2>Installing MicroPython<a class="headerlink" href="#installing-micropython" title="Permalink to this heading">¶</a></h2>
<p>See the corresponding section of tutorial: <a class="reference internal" href="tutorial/intro.html#esp32-intro"><span class="std std-ref">Getting started with MicroPython on the ESP32</span></a>. It also includes
a troubleshooting subsection.</p>
</section>
<section id="general-board-control">
<h2>General board control<a class="headerlink" href="#general-board-control" title="Permalink to this heading">¶</a></h2>
<p>The MicroPython REPL is on UART0 (GPIO1=TX, GPIO3=RX) at baudrate 115200.
Tab-completion is useful to find out what methods an object has.
Paste mode (ctrl-E) is useful to paste a large slab of Python code into
the REPL.</p>
<p>The <a class="reference internal" href="../library/machine.html#module-machine" title="machine: functions related to the hardware"><code class="xref py py-mod docutils literal notranslate"><span class="pre">machine</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span>

<span class="n">machine</span><span class="o">.</span><span class="n">freq</span><span class="p">()</span>          <span class="c1"># get the current frequency of the CPU</span>
<span class="n">machine</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="mi">240000000</span><span class="p">)</span> <span class="c1"># set the CPU frequency to 240 MHz</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/esp.html#module-esp" title="esp: functions related to the ESP8266 and ESP32"><code class="xref py py-mod docutils literal notranslate"><span class="pre">esp</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">esp</span>

<span class="n">esp</span><span class="o">.</span><span class="n">osdebug</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>       <span class="c1"># turn off vendor O/S debugging messages</span>
<span class="n">esp</span><span class="o">.</span><span class="n">osdebug</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>          <span class="c1"># redirect vendor O/S debugging messages to UART(0)</span>

<span class="c1"># low level methods to interact with flash storage</span>
<span class="n">esp</span><span class="o">.</span><span class="n">flash_size</span><span class="p">()</span>
<span class="n">esp</span><span class="o">.</span><span class="n">flash_user_start</span><span class="p">()</span>
<span class="n">esp</span><span class="o">.</span><span class="n">flash_erase</span><span class="p">(</span><span class="n">sector_no</span><span class="p">)</span>
<span class="n">esp</span><span class="o">.</span><span class="n">flash_write</span><span class="p">(</span><span class="n">byte_offset</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
<span class="n">esp</span><span class="o">.</span><span class="n">flash_read</span><span class="p">(</span><span class="n">byte_offset</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/esp32.html#module-esp32" title="esp32: functionality specific to the ESP32"><code class="xref py py-mod docutils literal notranslate"><span class="pre">esp32</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">esp32</span>

<span class="n">esp32</span><span class="o">.</span><span class="n">raw_temperature</span><span class="p">()</span> <span class="c1"># read the internal temperature of the MCU, in Fahrenheit</span>
<span class="n">esp32</span><span class="o">.</span><span class="n">ULP</span><span class="p">()</span>             <span class="c1"># access to the Ultra-Low-Power Co-processor</span>
</pre></div>
</div>
<p>Note that the temperature sensor in the ESP32 will typically read higher than
ambient due to the IC getting warm while it runs.  This effect can be minimised
by reading the temperature sensor immediately after waking up from sleep.</p>
</section>
<section id="networking">
<h2>Networking<a class="headerlink" href="#networking" title="Permalink to this heading">¶</a></h2>
<section id="wlan">
<h3>WLAN<a class="headerlink" href="#wlan" title="Permalink to this heading">¶</a></h3>
<p>The <a class="reference internal" href="../library/network.html#module-network" title="network: network configuration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">network</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">network</span>

<span class="n">wlan</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">WLAN</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">STA_IF</span><span class="p">)</span> <span class="c1"># create station interface</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">active</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>       <span class="c1"># activate the interface</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>             <span class="c1"># scan for access points</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">isconnected</span><span class="p">()</span>      <span class="c1"># check if the station is connected to an AP</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ssid&#39;</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span> <span class="c1"># connect to an AP</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="s1">&#39;mac&#39;</span><span class="p">)</span>      <span class="c1"># get the interface&#39;s MAC address</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">ifconfig</span><span class="p">()</span>         <span class="c1"># get the interface&#39;s IP/netmask/gw/DNS addresses</span>

<span class="n">ap</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">WLAN</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">AP_IF</span><span class="p">)</span> <span class="c1"># create access-point interface</span>
<span class="n">ap</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">ssid</span><span class="o">=</span><span class="s1">&#39;ESP-AP&#39;</span><span class="p">)</span> <span class="c1"># set the SSID of the access point</span>
<span class="n">ap</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">max_clients</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># set how many clients can connect to the network</span>
<span class="n">ap</span><span class="o">.</span><span class="n">active</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>         <span class="c1"># activate the interface</span>
</pre></div>
</div>
<p>A useful function for connecting to your local WiFi network is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_connect</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">network</span>
    <span class="n">wlan</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">WLAN</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">STA_IF</span><span class="p">)</span>
    <span class="n">wlan</span><span class="o">.</span><span class="n">active</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">wlan</span><span class="o">.</span><span class="n">isconnected</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;connecting to network...&#39;</span><span class="p">)</span>
        <span class="n">wlan</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ssid&#39;</span><span class="p">,</span> <span class="s1">&#39;key&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">wlan</span><span class="o">.</span><span class="n">isconnected</span><span class="p">():</span>
            <span class="k">pass</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;network config:&#39;</span><span class="p">,</span> <span class="n">wlan</span><span class="o">.</span><span class="n">ifconfig</span><span class="p">())</span>
</pre></div>
</div>
<p>Once the network is established the <a class="reference internal" href="../library/socket.html#module-socket" title="socket: socket module"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module can be used
to create and use TCP/UDP sockets as usual, and the <code class="docutils literal notranslate"><span class="pre">requests</span></code> module for
convenient HTTP requests.</p>
<p>After a call to <code class="docutils literal notranslate"><span class="pre">wlan.connect()</span></code>, the device will by default retry to connect
<strong>forever</strong>, even when the authentication failed or no AP is in range.
<code class="docutils literal notranslate"><span class="pre">wlan.status()</span></code> will return <code class="docutils literal notranslate"><span class="pre">network.STAT_CONNECTING</span></code> in this state until a
connection succeeds or the interface gets disabled.  This can be changed by
calling <code class="docutils literal notranslate"><span class="pre">wlan.config(reconnects=n)</span></code>, where n are the number of desired reconnect
attempts (0 means it won’t retry, -1 will restore the default behaviour of trying
to reconnect forever).</p>
</section>
<section id="lan">
<h3>LAN<a class="headerlink" href="#lan" title="Permalink to this heading">¶</a></h3>
<p>To use the wired interfaces one has to specify the pins and mode</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">network</span>

<span class="n">lan</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">LAN</span><span class="p">(</span><span class="n">mdc</span><span class="o">=</span><span class="n">PIN_MDC</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>   <span class="c1"># Set the pin and mode configuration</span>
<span class="n">lan</span><span class="o">.</span><span class="n">active</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>                      <span class="c1"># activate the interface</span>
<span class="n">lan</span><span class="o">.</span><span class="n">ifconfig</span><span class="p">()</span>                        <span class="c1"># get the interface&#39;s IP/netmask/gw/DNS addresses</span>
</pre></div>
</div>
<p>The keyword arguments for the constructor defining the PHY type and interface are:</p>
<ul class="simple">
<li><p>mdc=pin-object    # set the mdc and mdio pins.</p></li>
<li><p>mdio=pin-object</p></li>
<li><p>power=pin-object  # set the pin which switches the power of the PHY device.</p></li>
<li><p>phy_type=&lt;type&gt;   # Select the PHY device type. Supported devices are PHY_LAN8710,
PHY_LAN8720, PH_IP101, PHY_RTL8201, PHY_DP83848 and PHY_KSZ8041</p></li>
<li><p>phy_addr=number   # The address number of the PHY device.</p></li>
<li><p>ref_clk_mode=mode # Defines, whether the ref_clk at the ESP32 is an input
or output. Suitable values are Pin.IN and Pin.OUT.</p></li>
<li><p>ref_clk=pin-object  # defines the Pin used for ref_clk.</p></li>
</ul>
<p>These are working configurations for LAN interfaces of popular boards:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Olimex ESP32-GATEWAY: power controlled by Pin(5)</span>
<span class="c1"># Olimex ESP32 PoE and ESP32-PoE ISO: power controlled by Pin(12)</span>

<span class="n">lan</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">LAN</span><span class="p">(</span><span class="n">mdc</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">23</span><span class="p">),</span> <span class="n">mdio</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span> <span class="n">power</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
                  <span class="n">phy_type</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">PHY_LAN8720</span><span class="p">,</span> <span class="n">phy_addr</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="n">ref_clk</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">17</span><span class="p">),</span> <span class="n">ref_clk_mode</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>

<span class="c1"># Wireless-Tag&#39;s WT32-ETH01</span>

<span class="n">lan</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">LAN</span><span class="p">(</span><span class="n">mdc</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">23</span><span class="p">),</span> <span class="n">mdio</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span>
                  <span class="n">phy_type</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">PHY_LAN8720</span><span class="p">,</span> <span class="n">phy_addr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="c1"># Wireless-Tag&#39;s WT32-ETH01 v1.4</span>

<span class="n">lan</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">LAN</span><span class="p">(</span><span class="n">mdc</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">23</span><span class="p">),</span> <span class="n">mdio</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span>
                  <span class="n">phy_type</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">PHY_LAN8720</span><span class="p">,</span> <span class="n">phy_addr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">power</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

<span class="c1"># Espressif ESP32-Ethernet-Kit_A_V1.2</span>

<span class="n">lan</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">LAN</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mdc</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">23</span><span class="p">),</span> <span class="n">mdio</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span> <span class="n">power</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
                  <span class="n">phy_type</span><span class="o">=</span><span class="n">network</span><span class="o">.</span><span class="n">PHY_IP101</span><span class="p">,</span> <span class="n">phy_addr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="delay-and-timing">
<h2>Delay and timing<a class="headerlink" href="#delay-and-timing" title="Permalink to this heading">¶</a></h2>
<p>Use the <a class="reference internal" href="../library/time.html#module-time" title="time: time related functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>           <span class="c1"># sleep for 1 second</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>      <span class="c1"># sleep for 500 milliseconds</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep_us</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>       <span class="c1"># sleep for 10 microseconds</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ticks_ms</span><span class="p">()</span> <span class="c1"># get millisecond counter</span>
<span class="n">delta</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ticks_diff</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ticks_ms</span><span class="p">(),</span> <span class="n">start</span><span class="p">)</span> <span class="c1"># compute time difference</span>
</pre></div>
</div>
</section>
<section id="timers">
<h2>Timers<a class="headerlink" href="#timers" title="Permalink to this heading">¶</a></h2>
<p>The ESP32 port has four hardware timers. Use the <a class="reference internal" href="../library/machine.Timer.html#machine-timer"><span class="std std-ref">machine.Timer</span></a> class
with a timer ID from 0 to 3 (inclusive):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Timer</span>

<span class="n">tim0</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">tim0</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">period</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">Timer</span><span class="o">.</span><span class="n">ONE_SHOT</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="nb">print</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="n">tim1</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">tim1</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">period</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">Timer</span><span class="o">.</span><span class="n">PERIODIC</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>The period is in milliseconds.</p>
<p>Virtual timers are not currently supported on this port.</p>
</section>
<section id="pins-and-gpio">
<span id="id1"></span><h2>Pins and GPIO<a class="headerlink" href="#pins-and-gpio" title="Permalink to this heading">¶</a></h2>
<p>Use the <a class="reference internal" href="../library/machine.Pin.html#machine-pin"><span class="std std-ref">machine.Pin</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>

<span class="n">p0</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>    <span class="c1"># create output pin on GPIO0</span>
<span class="n">p0</span><span class="o">.</span><span class="n">on</span><span class="p">()</span>                 <span class="c1"># set pin to &quot;on&quot; (high) level</span>
<span class="n">p0</span><span class="o">.</span><span class="n">off</span><span class="p">()</span>                <span class="c1"># set pin to &quot;off&quot; (low) level</span>
<span class="n">p0</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>             <span class="c1"># set pin to on/high</span>

<span class="n">p2</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">)</span>     <span class="c1"># create input pin on GPIO2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>       <span class="c1"># get value, 0 or 1</span>

<span class="n">p4</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">PULL_UP</span><span class="p">)</span> <span class="c1"># enable internal pull-up resistor</span>
<span class="n">p5</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># set pin high on creation</span>
<span class="n">p6</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">,</span> <span class="n">drive</span><span class="o">=</span><span class="n">Pin</span><span class="o">.</span><span class="n">DRIVE_3</span><span class="p">)</span> <span class="c1"># set maximum drive strength</span>
</pre></div>
</div>
<p>Available Pins are from the following ranges (inclusive): 0-19, 21-23, 25-27, 32-39.
These correspond to the actual GPIO pin numbers of ESP32 chip.  Note that many
end-user boards use their own adhoc pin numbering (marked e.g. D0, D1, …).
For mapping between board logical pins and physical chip pins consult your board
documentation.</p>
<p>Four drive strengths are supported, using the <code class="docutils literal notranslate"><span class="pre">drive</span></code> keyword argument to the
<code class="docutils literal notranslate"><span class="pre">Pin()</span></code> constructor or <code class="docutils literal notranslate"><span class="pre">Pin.init()</span></code> method, with different corresponding
safe maximum source/sink currents and approximate internal driver resistances:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Pin.DRIVE_0</span></code>: 5mA / 130 ohm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pin.DRIVE_1</span></code>: 10mA / 60 ohm</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pin.DRIVE_2</span></code>: 20mA / 30 ohm (default strength if not configured)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Pin.DRIVE_3</span></code>: 40mA / 15 ohm</p></li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">hold=</span></code> keyword argument to <code class="docutils literal notranslate"><span class="pre">Pin()</span></code> and <code class="docutils literal notranslate"><span class="pre">Pin.init()</span></code> will enable the
ESP32 “pad hold” feature. When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the pin configuration
(direction, pull resistors and output value) will be held and any further
changes (including changing the output level) will not be applied. Setting
<code class="docutils literal notranslate"><span class="pre">hold=False</span></code> will immediately apply any outstanding pin configuration changes
and release the pin. Using <code class="docutils literal notranslate"><span class="pre">hold=True</span></code> while a pin is already held will apply
any configuration changes and then immediately reapply the hold.</p>
<p>Notes:</p>
<ul class="simple">
<li><p>Pins 1 and 3 are REPL UART TX and RX respectively</p></li>
<li><p>Pins 6, 7, 8, 11, 16, and 17 are used for connecting the embedded flash,
and are not recommended for other uses</p></li>
<li><p>Pins 34-39 are input only, and also do not have internal pull-up resistors</p></li>
<li><p>See <a class="reference internal" href="#deep-sleep-mode"><span class="std std-ref">Deep-sleep mode</span></a> for a discussion of pin behaviour during sleep</p></li>
</ul>
<p>There’s a higher-level abstraction <a class="reference internal" href="../library/machine.Signal.html#machine-signal"><span class="std std-ref">machine.Signal</span></a>
which can be used to invert a pin. Useful for illuminating active-low LEDs
using <code class="docutils literal notranslate"><span class="pre">on()</span></code> or <code class="docutils literal notranslate"><span class="pre">value(1)</span></code>.</p>
</section>
<section id="uart-serial-bus">
<h2>UART (serial bus)<a class="headerlink" href="#uart-serial-bus" title="Permalink to this heading">¶</a></h2>
<p>See <a class="reference internal" href="../library/machine.UART.html#machine-uart"><span class="std std-ref">machine.UART</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">UART</span>

<span class="n">uart1</span> <span class="o">=</span> <span class="n">UART</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">baudrate</span><span class="o">=</span><span class="mi">9600</span><span class="p">,</span> <span class="n">tx</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span> <span class="n">rx</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span class="n">uart1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>  <span class="c1"># write 5 bytes</span>
<span class="n">uart1</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>         <span class="c1"># read up to 5 bytes</span>
</pre></div>
</div>
<p>The ESP32 has three hardware UARTs: UART0, UART1 and UART2.
They each have default GPIO assigned to them, however depending on your
ESP32 variant and board, these pins may conflict with embedded flash,
onboard PSRAM or peripherals.</p>
<p>Any GPIO can be used for hardware UARTs using the GPIO matrix, except for
input-only pins 34-39 that can be used as <code class="docutils literal notranslate"><span class="pre">rx</span></code>. To avoid conflicts simply
provide <code class="docutils literal notranslate"><span class="pre">tx</span></code> and <code class="docutils literal notranslate"><span class="pre">rx</span></code> pins when constructing. The default pins listed
below.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p>UART0</p></th>
<th class="head"><p>UART1</p></th>
<th class="head"><p>UART2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tx</p></td>
<td><p>1</p></td>
<td><p>10</p></td>
<td><p>17</p></td>
</tr>
<tr class="row-odd"><td><p>rx</p></td>
<td><p>3</p></td>
<td><p>9</p></td>
<td><p>16</p></td>
</tr>
</tbody>
</table>
</section>
<section id="pwm-pulse-width-modulation">
<h2>PWM (pulse width modulation)<a class="headerlink" href="#pwm-pulse-width-modulation" title="Permalink to this heading">¶</a></h2>
<p>PWM can be enabled on all output-enabled pins. The base frequency can
range from 1Hz to 40MHz but there is a tradeoff; as the base frequency
<em>increases</em> the duty resolution <em>decreases</em>. See
<a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/ledc.html">LED Control</a>
for more details.</p>
<p>Use the <a class="reference internal" href="../library/machine.PWM.html#machine-pwm"><span class="std std-ref">machine.PWM</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">PWM</span>

<span class="n">pwm0</span> <span class="o">=</span> <span class="n">PWM</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">duty_u16</span><span class="o">=</span><span class="mi">32768</span><span class="p">)</span> <span class="c1"># create PWM object from a pin</span>
<span class="n">freq</span> <span class="o">=</span> <span class="n">pwm0</span><span class="o">.</span><span class="n">freq</span><span class="p">()</span>         <span class="c1"># get current frequency</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>            <span class="c1"># set PWM frequency from 1Hz to 40MHz</span>

<span class="n">duty</span> <span class="o">=</span> <span class="n">pwm0</span><span class="o">.</span><span class="n">duty</span><span class="p">()</span>         <span class="c1"># get current duty cycle, range 0-1023 (default 512, 50%)</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">duty</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span>             <span class="c1"># set duty cycle from 0 to 1023 as a ratio duty/1023, (now 25%)</span>

<span class="n">duty_u16</span> <span class="o">=</span> <span class="n">pwm0</span><span class="o">.</span><span class="n">duty_u16</span><span class="p">()</span> <span class="c1"># get current duty cycle, range 0-65535</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">duty_u16</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">*</span><span class="mi">3</span><span class="o">//</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># set duty cycle from 0 to 65535 as a ratio duty_u16/65535, (now 75%)</span>

<span class="n">duty_ns</span> <span class="o">=</span> <span class="n">pwm0</span><span class="o">.</span><span class="n">duty_ns</span><span class="p">()</span>   <span class="c1"># get current pulse width in ns</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">duty_ns</span><span class="p">(</span><span class="mi">250_000</span><span class="p">)</span>      <span class="c1"># set pulse width in nanoseconds from 0 to 1_000_000_000/freq, (now 25%)</span>

<span class="n">pwm0</span><span class="o">.</span><span class="n">deinit</span><span class="p">()</span>              <span class="c1"># turn off PWM on the pin</span>

<span class="n">pwm2</span> <span class="o">=</span> <span class="n">PWM</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">duty</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>  <span class="c1"># create and configure in one go</span>
<span class="nb">print</span><span class="p">(</span><span class="n">pwm2</span><span class="p">)</span>                               <span class="c1"># view PWM settings</span>
</pre></div>
</div>
<p>ESP chips have different hardware peripherals:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Hardware specification</p></td>
<td><p>ESP32</p></td>
<td><p>ESP32-S2</p></td>
<td><p>ESP32-C3</p></td>
</tr>
<tr class="row-even"><td><p>Number of groups (speed modes)</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>Number of timers per group</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>Number of channels per group</p></td>
<td><p>8</p></td>
<td><p>8</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>Different PWM frequencies (groups * timers)</p></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>Total PWM channels (Pins, duties) (groups * channels)</p></td>
<td><p>16</p></td>
<td><p>8</p></td>
<td><p>6</p></td>
</tr>
</tbody>
</table>
<p>A maximum number of PWM channels (Pins) are available on the ESP32 - 16 channels,
but only 8 different PWM frequencies are available, the remaining 8 channels must
have the same frequency.  On the other hand, 16 independent PWM duty cycles are
possible at the same frequency.</p>
<p>See more examples in the <a class="reference internal" href="tutorial/pwm.html#esp32-pwm"><span class="std std-ref">Pulse Width Modulation</span></a> tutorial.</p>
</section>
<section id="dac-digital-to-analog-conversion">
<h2>DAC (digital to analog conversion)<a class="headerlink" href="#dac-digital-to-analog-conversion" title="Permalink to this heading">¶</a></h2>
<p>On the ESP32, DAC functionality is available on pins 25, 26.
On the ESP32S2, DAC functionality is available on pins 17, 18.</p>
<p>Use the DAC:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">DAC</span><span class="p">,</span> <span class="n">Pin</span>

<span class="n">dac</span> <span class="o">=</span> <span class="n">DAC</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">25</span><span class="p">))</span>  <span class="c1"># create an DAC object acting on a pin</span>
<span class="n">dac</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>      <span class="c1"># set a raw analog value in the range 0-255, 50% now</span>
</pre></div>
</div>
</section>
<section id="adc-analog-to-digital-conversion">
<h2>ADC (analog to digital conversion)<a class="headerlink" href="#adc-analog-to-digital-conversion" title="Permalink to this heading">¶</a></h2>
<p>On the ESP32, ADC functionality is available on pins 32-39 (ADC block 1) and
pins 0, 2, 4, 12-15 and 25-27 (ADC block 2).</p>
<p>Use the <a class="reference internal" href="../library/machine.ADC.html#machine-adc"><span class="std std-ref">machine.ADC</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">ADC</span>

<span class="n">adc</span> <span class="o">=</span> <span class="n">ADC</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>        <span class="c1"># create an ADC object acting on a pin</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">adc</span><span class="o">.</span><span class="n">read_u16</span><span class="p">()</span>  <span class="c1"># read a raw analog value in the range 0-65535</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">adc</span><span class="o">.</span><span class="n">read_uv</span><span class="p">()</span>   <span class="c1"># read an analog value in microvolts</span>
</pre></div>
</div>
<p>ADC block 2 is also used by WiFi and so attempting to read analog values from
block 2 pins when WiFi is active will raise an exception.</p>
<p>The internal ADC reference voltage is typically 1.1V, but varies slightly from
package to package. The ADC is less linear close to the reference voltage
(particularly at higher attenuations) and has a minimum measurement voltage
around 100mV, voltages at or below this will read as 0. To read voltages
accurately, it is recommended to use the <code class="docutils literal notranslate"><span class="pre">read_uv()</span></code> method (see below).</p>
<p>ESP32-specific ADC class method reference:</p>
<dl class="py class">
<dt class="sig sig-object py" id="ADC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ADC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pin</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atten</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ADC" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ADC object for the specified pin. ESP32 does not support
different timings for ADC sampling and so the <code class="docutils literal notranslate"><span class="pre">sample_ns</span></code> keyword argument
is not supported.</p>
<p>To read voltages above the reference voltage, apply input attenuation with
the <code class="docutils literal notranslate"><span class="pre">atten</span></code> keyword argument. Valid values (and approximate linear
measurement ranges) are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.ATTN_0DB</span></code>: No attenuation (100mV - 950mV)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.ATTN_2_5DB</span></code>: 2.5dB attenuation (100mV - 1250mV)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.ATTN_6DB</span></code>: 6dB attenuation (150mV - 1750mV)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.ATTN_11DB</span></code>: 11dB attenuation (150mV - 2450mV)</p></li>
</ul>
</div></blockquote>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that the absolute maximum voltage rating for input pins is 3.6V. Going
near to this boundary risks damage to the IC!</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ADC.read_uv">
<span class="sig-prename descclassname"><span class="pre">ADC.</span></span><span class="sig-name descname"><span class="pre">read_uv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ADC.read_uv" title="Permalink to this definition">¶</a></dt>
<dd><p>This method uses the known characteristics of the ADC and per-package eFuse
values - set during manufacture - to return a calibrated input voltage
(before attenuation) in microvolts. The returned value has only millivolt
resolution (i.e., will always be a multiple of 1000 microvolts).</p>
<p>The calibration is only valid across the linear range of the ADC. In
particular, an input tied to ground will read as a value above 0 microvolts.
Within the linear range, however, more accurate and consistent results will
be obtained than using <a class="reference internal" href="../samd/quickref.html#read_u16" title="read_u16"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">read_u16()</span></code></a> and scaling the result with a constant.</p>
</dd></dl>

<p>The ESP32 port also supports the <a class="reference internal" href="../library/machine.ADCBlock.html#machine-adcblock"><span class="std std-ref">machine.ADC</span></a> API:</p>
<dl class="py class">
<dt class="sig sig-object py" id="ADCBlock">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ADCBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ADCBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ADC block object with the given <code class="docutils literal notranslate"><span class="pre">id</span></code> (1 or 2) and initialize
it to the specified resolution (9 to 12-bits depending on the ESP32 series)
or the highest supported resolution if not specified.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ADCBlock.connect">
<span class="sig-prename descclassname"><span class="pre">ADCBlock.</span></span><span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ADCBlock.connect" title="Permalink to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ADCBlock.</span></span><span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span></em><span class="sig-paren">)</span></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ADCBlock.</span></span><span class="sig-name descname"><span class="pre">connect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pin</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return the <code class="docutils literal notranslate"><span class="pre">ADC</span></code> object for the specified ADC pin or channel number.
Arbitrary connection of ADC channels to GPIO is not supported and so
specifying a pin that is not connected to this block, or specifying a
mismatched channel and pin, will raise an exception.</p>
</dd></dl>

<p>Legacy methods:</p>
<dl class="py method">
<dt class="sig sig-object py" id="ADC.read">
<span class="sig-prename descclassname"><span class="pre">ADC.</span></span><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ADC.read" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns the raw ADC value ranged according to the resolution of
the block, e.g., 0-4095 for 12-bit resolution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ADC.atten">
<span class="sig-prename descclassname"><span class="pre">ADC.</span></span><span class="sig-name descname"><span class="pre">atten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atten</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ADC.atten" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">ADC.init(atten=atten)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ADC.width">
<span class="sig-prename descclassname"><span class="pre">ADC.</span></span><span class="sig-name descname"><span class="pre">width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bits</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ADC.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">ADC.block().init(bits=bits)</span></code>.</p>
</dd></dl>

<p>For compatibility, the <code class="docutils literal notranslate"><span class="pre">ADC</span></code> object also provides constants matching the
supported ADC resolutions:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.WIDTH_9BIT</span></code> = 9</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.WIDTH_10BIT</span></code> = 10</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.WIDTH_11BIT</span></code> = 11</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.WIDTH_12BIT</span></code> = 12</p></li>
</ul>
</div></blockquote>
</section>
<section id="software-spi-bus">
<h2>Software SPI bus<a class="headerlink" href="#software-spi-bus" title="Permalink to this heading">¶</a></h2>
<p>Software SPI (using bit-banging) works on all pins, and is accessed via the
<a class="reference internal" href="../library/machine.SPI.html#machine-softspi"><span class="std std-ref">machine.SoftSPI</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">SoftSPI</span>

<span class="c1"># construct a SoftSPI bus on the given pins</span>
<span class="c1"># polarity is the idle state of SCK</span>
<span class="c1"># phase=0 means sample on the first edge of SCK, phase=1 means the second</span>
<span class="n">spi</span> <span class="o">=</span> <span class="n">SoftSPI</span><span class="p">(</span><span class="n">baudrate</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">polarity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mosi</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">miso</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>

<span class="n">spi</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">baudrate</span><span class="o">=</span><span class="mi">200000</span><span class="p">)</span> <span class="c1"># set the baudrate</span>

<span class="n">spi</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>            <span class="c1"># read 10 bytes on MISO</span>
<span class="n">spi</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">)</span>      <span class="c1"># read 10 bytes while outputting 0xff on MOSI</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>     <span class="c1"># create a buffer</span>
<span class="n">spi</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>       <span class="c1"># read into the given buffer (reads 50 bytes in this case)</span>
<span class="n">spi</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">)</span> <span class="c1"># read into the given buffer and output 0xff on MOSI</span>

<span class="n">spi</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;12345&#39;</span><span class="p">)</span>     <span class="c1"># write 5 bytes on MOSI</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>      <span class="c1"># create a buffer</span>
<span class="n">spi</span><span class="o">.</span><span class="n">write_readinto</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;1234&#39;</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="c1"># write to MOSI and read from MISO into the buffer</span>
<span class="n">spi</span><span class="o">.</span><span class="n">write_readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="c1"># write buf to MOSI and read MISO back into buf</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently <em>all</em> of <code class="docutils literal notranslate"><span class="pre">sck</span></code>, <code class="docutils literal notranslate"><span class="pre">mosi</span></code> and <code class="docutils literal notranslate"><span class="pre">miso</span></code> <em>must</em> be specified when
initialising Software SPI.</p>
</div>
</section>
<section id="hardware-spi-bus">
<h2>Hardware SPI bus<a class="headerlink" href="#hardware-spi-bus" title="Permalink to this heading">¶</a></h2>
<p>There are two hardware SPI channels that allow faster transmission
rates (up to 80Mhz). These may be used on any IO pins that support the
required direction and are otherwise unused (see <a class="reference internal" href="#pins-and-gpio"><span class="std std-ref">Pins and GPIO</span></a>)
but if they are not configured to their default pins then they need to
pass through an extra layer of GPIO multiplexing, which can impact
their reliability at high speeds. Hardware SPI channels are limited
to 40MHz when used on pins other than the default ones listed below.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p>HSPI (id=1)</p></th>
<th class="head"><p>VSPI (id=2)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sck</p></td>
<td><p>14</p></td>
<td><p>18</p></td>
</tr>
<tr class="row-odd"><td><p>mosi</p></td>
<td><p>13</p></td>
<td><p>23</p></td>
</tr>
<tr class="row-even"><td><p>miso</p></td>
<td><p>12</p></td>
<td><p>19</p></td>
</tr>
</tbody>
</table>
<p>Hardware SPI is accessed via the <a class="reference internal" href="../library/machine.SPI.html#machine-spi"><span class="std std-ref">machine.SPI</span></a> class and
has the same methods as software SPI above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">SPI</span>

<span class="n">hspi</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000000</span><span class="p">)</span>
<span class="n">hspi</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000000</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">14</span><span class="p">),</span> <span class="n">mosi</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="n">miso</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
<span class="n">vspi</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">baudrate</span><span class="o">=</span><span class="mi">80000000</span><span class="p">,</span> <span class="n">polarity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">firstbit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span> <span class="n">mosi</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">23</span><span class="p">),</span> <span class="n">miso</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="software-i2c-bus">
<h2>Software I2C bus<a class="headerlink" href="#software-i2c-bus" title="Permalink to this heading">¶</a></h2>
<p>Software I2C (using bit-banging) works on all output-capable pins, and is
accessed via the <a class="reference internal" href="../library/machine.I2C.html#machine-softi2c"><span class="std std-ref">machine.SoftI2C</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">SoftI2C</span>

<span class="n">i2c</span> <span class="o">=</span> <span class="n">SoftI2C</span><span class="p">(</span><span class="n">scl</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">sda</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>

<span class="n">i2c</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>              <span class="c1"># scan for devices</span>

<span class="n">i2c</span><span class="o">.</span><span class="n">readfrom</span><span class="p">(</span><span class="mh">0x3a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>   <span class="c1"># read 4 bytes from device with address 0x3a</span>
<span class="n">i2c</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="mh">0x3a</span><span class="p">,</span> <span class="s1">&#39;12&#39;</span><span class="p">)</span> <span class="c1"># write &#39;12&#39; to device with address 0x3a</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>     <span class="c1"># create a buffer with 10 bytes</span>
<span class="n">i2c</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="mh">0x3a</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>  <span class="c1"># write the given buffer to the peripheral</span>
</pre></div>
</div>
</section>
<section id="hardware-i2c-bus">
<h2>Hardware I2C bus<a class="headerlink" href="#hardware-i2c-bus" title="Permalink to this heading">¶</a></h2>
<p>There are two hardware I2C peripherals with identifiers 0 and 1.  Any available
output-capable pins can be used for SCL and SDA but the defaults are given
below.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p>I2C(0)</p></th>
<th class="head"><p>I2C(1)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>scl</p></td>
<td><p>18</p></td>
<td><p>25</p></td>
</tr>
<tr class="row-odd"><td><p>sda</p></td>
<td><p>19</p></td>
<td><p>26</p></td>
</tr>
</tbody>
</table>
<p>The driver is accessed via the <a class="reference internal" href="../library/machine.I2C.html#machine-i2c"><span class="std std-ref">machine.I2C</span></a> class and
has the same methods as software I2C above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">I2C</span>

<span class="n">i2c</span> <span class="o">=</span> <span class="n">I2C</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">i2c</span> <span class="o">=</span> <span class="n">I2C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scl</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">sda</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="mi">400000</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="i2s-bus">
<h2>I2S bus<a class="headerlink" href="#i2s-bus" title="Permalink to this heading">¶</a></h2>
<p>See <a class="reference internal" href="../library/machine.I2S.html#machine-i2s"><span class="std std-ref">machine.I2S</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">I2S</span><span class="p">,</span> <span class="n">Pin</span>

<span class="n">i2s</span> <span class="o">=</span> <span class="n">I2S</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="n">ws</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">14</span><span class="p">),</span> <span class="n">sd</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">34</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">I2S</span><span class="o">.</span><span class="n">TX</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">I2S</span><span class="o">.</span><span class="n">STEREO</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">44100</span><span class="p">,</span> <span class="n">ibuf</span><span class="o">=</span><span class="mi">40000</span><span class="p">)</span> <span class="c1"># create I2S object</span>
<span class="n">i2s</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>             <span class="c1"># write buffer of audio samples to I2S device</span>

<span class="n">i2s</span> <span class="o">=</span> <span class="n">I2S</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">33</span><span class="p">),</span> <span class="n">ws</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span> <span class="n">sd</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">I2S</span><span class="o">.</span><span class="n">RX</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">I2S</span><span class="o">.</span><span class="n">MONO</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">ibuf</span><span class="o">=</span><span class="mi">40000</span><span class="p">)</span> <span class="c1"># create I2S object</span>
<span class="n">i2s</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>          <span class="c1"># fill buffer with audio samples from I2S device</span>
</pre></div>
</div>
<p>The I2S class is currently available as a Technical Preview.  During the preview period, feedback from
users is encouraged.  Based on this feedback, the I2S class API and implementation may be changed.</p>
<p>ESP32 has two I2S buses with id=0 and id=1</p>
</section>
<section id="real-time-clock-rtc">
<h2>Real time clock (RTC)<a class="headerlink" href="#real-time-clock-rtc" title="Permalink to this heading">¶</a></h2>
<p>See <a class="reference internal" href="../library/machine.RTC.html#machine-rtc"><span class="std std-ref">machine.RTC</span></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">RTC</span>

<span class="n">rtc</span> <span class="o">=</span> <span class="n">RTC</span><span class="p">()</span>
<span class="n">rtc</span><span class="o">.</span><span class="n">datetime</span><span class="p">((</span><span class="mi">2017</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c1"># set a specific date and time</span>
<span class="n">rtc</span><span class="o">.</span><span class="n">datetime</span><span class="p">()</span> <span class="c1"># get date and time</span>
</pre></div>
</div>
</section>
<section id="wdt-watchdog-timer">
<h2>WDT (Watchdog timer)<a class="headerlink" href="#wdt-watchdog-timer" title="Permalink to this heading">¶</a></h2>
<p>See <a class="reference internal" href="../library/machine.WDT.html#machine-wdt"><span class="std std-ref">machine.WDT</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">WDT</span>

<span class="c1"># enable the WDT with a timeout of 5s (1s is the minimum)</span>
<span class="n">wdt</span> <span class="o">=</span> <span class="n">WDT</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="n">wdt</span><span class="o">.</span><span class="n">feed</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="deep-sleep-mode">
<span id="id2"></span><h2>Deep-sleep mode<a class="headerlink" href="#deep-sleep-mode" title="Permalink to this heading">¶</a></h2>
<p>The following code can be used to sleep, wake and check the reset cause:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span>

<span class="c1"># check if the device woke from a deep sleep</span>
<span class="k">if</span> <span class="n">machine</span><span class="o">.</span><span class="n">reset_cause</span><span class="p">()</span> <span class="o">==</span> <span class="n">machine</span><span class="o">.</span><span class="n">DEEPSLEEP_RESET</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;woke from a deep sleep&#39;</span><span class="p">)</span>

<span class="c1"># put the device to sleep for 10 seconds</span>
<span class="n">machine</span><span class="o">.</span><span class="n">deepsleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
</pre></div>
</div>
<p>Notes:</p>
<ul class="simple">
<li><p>Calling <code class="docutils literal notranslate"><span class="pre">deepsleep()</span></code> without an argument will put the device to sleep
indefinitely</p></li>
<li><p>A software reset does not change the reset cause</p></li>
</ul>
<p>Some ESP32 pins (0, 2, 4, 12-15, 25-27, 32-39) are connected to the RTC during
deep-sleep and can be used to wake the device with the <code class="docutils literal notranslate"><span class="pre">wake_on_</span></code> functions in
the <a class="reference internal" href="../library/esp32.html#module-esp32" title="esp32: functionality specific to the ESP32"><code class="xref py py-mod docutils literal notranslate"><span class="pre">esp32</span></code></a> module. The output-capable RTC pins (all except 34-39) will
also retain their pull-up or pull-down resistor configuration when entering
deep-sleep.</p>
<p>If the pull resistors are not actively required during deep-sleep and are likely
to cause current leakage (for example a pull-up resistor is connected to ground
through a switch), then they should be disabled to save power before entering
deep-sleep mode:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">deepsleep</span>

<span class="c1"># configure input RTC pin with pull-up on boot</span>
<span class="n">pin</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">PULL_UP</span><span class="p">)</span>

<span class="c1"># disable pull-up and put the device to sleep for 10 seconds</span>
<span class="n">pin</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">pull</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">machine</span><span class="o">.</span><span class="n">deepsleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
</pre></div>
</div>
<p>Output-configured RTC pins will also retain their output direction and level in
deep-sleep if pad hold is enabled with the <code class="docutils literal notranslate"><span class="pre">hold=True</span></code> argument to
<code class="docutils literal notranslate"><span class="pre">Pin.init()</span></code>.</p>
<p>Non-RTC GPIO pins will be disconnected by default on entering deep-sleep.
Configuration of non-RTC pins - including output level - can be retained by
enabling pad hold on the pin and enabling GPIO pad hold during deep-sleep:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">deepsleep</span>
<span class="kn">import</span> <span class="nn">esp32</span>

<span class="n">opin</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">19</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># hold output level</span>
<span class="n">ipin</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">PULL_UP</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># hold pull-up</span>

<span class="c1"># enable pad hold in deep-sleep for non-RTC GPIO</span>
<span class="n">esp32</span><span class="o">.</span><span class="n">gpio_deep_sleep_hold</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># put the device to sleep for 10 seconds</span>
<span class="n">deepsleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
</pre></div>
</div>
<p>The pin configuration - including the pad hold - will be retained on wake from
sleep. See <a class="reference internal" href="#pins-and-gpio"><span class="std std-ref">Pins and GPIO</span></a> above for a further discussion of pad holding.</p>
</section>
<section id="sd-card">
<h2>SD card<a class="headerlink" href="#sd-card" title="Permalink to this heading">¶</a></h2>
<p>See <a class="reference internal" href="../library/machine.SDCard.html#machine-sdcard"><span class="std std-ref">machine.SDCard</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span><span class="o">,</span> <span class="nn">os</span>

<span class="c1"># Slot 2 uses pins sck=18, cs=5, miso=19, mosi=23</span>
<span class="n">sd</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">SDCard</span><span class="p">(</span><span class="n">slot</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">os</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="s1">&#39;/sd&#39;</span><span class="p">)</span>  <span class="c1"># mount</span>

<span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;/sd&#39;</span><span class="p">)</span>    <span class="c1"># list directory contents</span>

<span class="n">os</span><span class="o">.</span><span class="n">umount</span><span class="p">(</span><span class="s1">&#39;/sd&#39;</span><span class="p">)</span>     <span class="c1"># eject</span>
</pre></div>
</div>
</section>
<section id="rmt">
<h2>RMT<a class="headerlink" href="#rmt" title="Permalink to this heading">¶</a></h2>
<p>The RMT is ESP32-specific and allows generation of accurate digital pulses with
12.5ns resolution.  See <a class="reference internal" href="../library/esp32.html#esp32-rmt"><span class="std std-ref">esp32.RMT</span></a> for details.  Usage is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">esp32</span>
<span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">esp32</span><span class="o">.</span><span class="n">RMT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pin</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span> <span class="n">clock_div</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">r</span>   <span class="c1"># RMT(channel=0, pin=18, source_freq=80000000, clock_div=8)</span>
<span class="c1"># The channel resolution is 100ns (1/(source_freq/clock_div)).</span>
<span class="n">r</span><span class="o">.</span><span class="n">write_pulses</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Send 0 for 100ns, 1 for 2000ns, 0 for 200ns, 1 for 4000ns</span>
</pre></div>
</div>
</section>
<section id="onewire-driver">
<h2>OneWire driver<a class="headerlink" href="#onewire-driver" title="Permalink to this heading">¶</a></h2>
<p>The OneWire driver is implemented in software and works on all pins:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>
<span class="kn">import</span> <span class="nn">onewire</span>

<span class="n">ow</span> <span class="o">=</span> <span class="n">onewire</span><span class="o">.</span><span class="n">OneWire</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span> <span class="c1"># create a OneWire bus on GPIO12</span>
<span class="n">ow</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>               <span class="c1"># return a list of devices on the bus</span>
<span class="n">ow</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>              <span class="c1"># reset the bus</span>
<span class="n">ow</span><span class="o">.</span><span class="n">readbyte</span><span class="p">()</span>           <span class="c1"># read a byte</span>
<span class="n">ow</span><span class="o">.</span><span class="n">writebyte</span><span class="p">(</span><span class="mh">0x12</span><span class="p">)</span>      <span class="c1"># write a byte on the bus</span>
<span class="n">ow</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>         <span class="c1"># write bytes on the bus</span>
<span class="n">ow</span><span class="o">.</span><span class="n">select_rom</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;12345678&#39;</span><span class="p">)</span> <span class="c1"># select a specific device by its ROM code</span>
</pre></div>
</div>
<p>There is a specific driver for DS18S20 and DS18B20 devices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">ds18x20</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">ds18x20</span><span class="o">.</span><span class="n">DS18X20</span><span class="p">(</span><span class="n">ow</span><span class="p">)</span>
<span class="n">roms</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
<span class="n">ds</span><span class="o">.</span><span class="n">convert_temp</span><span class="p">()</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep_ms</span><span class="p">(</span><span class="mi">750</span><span class="p">)</span>
<span class="k">for</span> <span class="n">rom</span> <span class="ow">in</span> <span class="n">roms</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">read_temp</span><span class="p">(</span><span class="n">rom</span><span class="p">))</span>
</pre></div>
</div>
<p>Be sure to put a 4.7k pull-up resistor on the data line.  Note that
the <code class="docutils literal notranslate"><span class="pre">convert_temp()</span></code> method must be called each time you want to
sample the temperature.</p>
</section>
<section id="neopixel-and-apa106-driver">
<h2>NeoPixel and APA106 driver<a class="headerlink" href="#neopixel-and-apa106-driver" title="Permalink to this heading">¶</a></h2>
<p>Use the <code class="docutils literal notranslate"><span class="pre">neopixel</span></code> and <code class="docutils literal notranslate"><span class="pre">apa106</span></code> modules:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>
<span class="kn">from</span> <span class="nn">neopixel</span> <span class="kn">import</span> <span class="n">NeoPixel</span>

<span class="n">pin</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>   <span class="c1"># set GPIO0 to output to drive NeoPixels</span>
<span class="n">np</span> <span class="o">=</span> <span class="n">NeoPixel</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>   <span class="c1"># create NeoPixel driver on GPIO0 for 8 pixels</span>
<span class="n">np</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span> <span class="c1"># set the first pixel to white</span>
<span class="n">np</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>              <span class="c1"># write data to all pixels</span>
<span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>         <span class="c1"># get first pixel colour</span>
</pre></div>
</div>
<p>The APA106 driver extends NeoPixel, but internally uses a different colour order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">apa106</span> <span class="kn">import</span> <span class="n">APA106</span>
<span class="n">ap</span> <span class="o">=</span> <span class="n">APA106</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>By default <code class="docutils literal notranslate"><span class="pre">NeoPixel</span></code> is configured to control the more popular <em>800kHz</em>
units. It is possible to use alternative timing to control other (typically
400kHz) devices by passing <code class="docutils literal notranslate"><span class="pre">timing=0</span></code> when constructing the
<code class="docutils literal notranslate"><span class="pre">NeoPixel</span></code> object.</p>
</div>
<p>For low-level driving of a NeoPixel see <a class="reference internal" href="../library/machine.html#machine.bitstream" title="machine.bitstream"><code class="xref any py py-func docutils literal notranslate"><span class="pre">machine.bitstream</span></code></a>.
This low-level driver uses an RMT channel by default.  To configure this see
<a class="reference internal" href="../library/esp32.html#esp32.RMT.bitstream_channel" title="esp32.RMT.bitstream_channel"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">RMT.bitstream_channel</span></code></a>.</p>
<p>APA102 (DotStar) uses a different driver as it has an additional clock pin.</p>
</section>
<section id="capacitive-touch">
<h2>Capacitive touch<a class="headerlink" href="#capacitive-touch" title="Permalink to this heading">¶</a></h2>
<p>Use the <code class="docutils literal notranslate"><span class="pre">TouchPad</span></code> class in the <code class="docutils literal notranslate"><span class="pre">machine</span></code> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">TouchPad</span><span class="p">,</span> <span class="n">Pin</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">TouchPad</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span>
<span class="n">t</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>              <span class="c1"># Returns a smaller number when touched</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TouchPad.read</span></code> returns a value relative to the capacitive variation. Small numbers (typically in
the <em>tens</em>) are common when a pin is touched, larger numbers (above <em>one thousand</em>) when
no touch is present. However the values are <em>relative</em> and can vary depending on the board
and surrounding composition so some calibration may be required.</p>
<p>There are ten capacitive touch-enabled pins that can be used on the ESP32: 0, 2, 4, 12, 13
14, 15, 27, 32, 33. Trying to assign to any other pins will result in a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
<p>Note that TouchPads can be used to wake an ESP32 from sleep:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span>
<span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">TouchPad</span><span class="p">,</span> <span class="n">Pin</span>
<span class="kn">import</span> <span class="nn">esp32</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">TouchPad</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span>
<span class="n">t</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>               <span class="c1"># configure the threshold at which the pin is considered touched</span>
<span class="n">esp32</span><span class="o">.</span><span class="n">wake_on_touch</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">machine</span><span class="o">.</span><span class="n">lightsleep</span><span class="p">()</span>        <span class="c1"># put the MCU to sleep until a touchpad is touched</span>
</pre></div>
</div>
<p>For more details on touchpads refer to <a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/touch_pad.html">Espressif Touch Sensor</a>.</p>
</section>
<section id="dht-driver">
<h2>DHT driver<a class="headerlink" href="#dht-driver" title="Permalink to this heading">¶</a></h2>
<p>The DHT driver is implemented in software and works on all pins:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dht</span>
<span class="kn">import</span> <span class="nn">machine</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">dht</span><span class="o">.</span><span class="n">DHT11</span><span class="p">(</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">d</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span>
<span class="n">d</span><span class="o">.</span><span class="n">temperature</span><span class="p">()</span> <span class="c1"># eg. 23 (°C)</span>
<span class="n">d</span><span class="o">.</span><span class="n">humidity</span><span class="p">()</span>    <span class="c1"># eg. 41 (% RH)</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">dht</span><span class="o">.</span><span class="n">DHT22</span><span class="p">(</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">d</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span>
<span class="n">d</span><span class="o">.</span><span class="n">temperature</span><span class="p">()</span> <span class="c1"># eg. 23.6 (°C)</span>
<span class="n">d</span><span class="o">.</span><span class="n">humidity</span><span class="p">()</span>    <span class="c1"># eg. 41.3 (% RH)</span>
</pre></div>
</div>
</section>
<section id="webrepl-web-browser-interactive-prompt">
<h2>WebREPL (web browser interactive prompt)<a class="headerlink" href="#webrepl-web-browser-interactive-prompt" title="Permalink to this heading">¶</a></h2>
<p>WebREPL (REPL over WebSockets, accessible via a web browser) is an
experimental feature available in ESP32 port. Download web client
from <a class="reference external" href="https://github.com/micropython/webrepl">https://github.com/micropython/webrepl</a> (hosted version available
at <a class="reference external" href="http://micropython.org/webrepl">http://micropython.org/webrepl</a>), and configure it by executing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">webrepl_setup</span>
</pre></div>
</div>
<p>and following on-screen instructions. After reboot, it will be available
for connection. If you disabled automatic start-up on boot, you may
run configured daemon on demand using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">webrepl</span>
<span class="n">webrepl</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># or, start with a specific password</span>
<span class="n">webrepl</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;mypass&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The WebREPL daemon listens on all active interfaces, which can be STA or
AP.  This allows you to connect to the ESP32 via a router (the STA
interface) or directly when connected to its access point.</p>
<p>In addition to terminal/command prompt access, WebREPL also has provision
for file transfer (both upload and download).  The web client has buttons for
the corresponding functions, or you can use the command-line client
<code class="docutils literal notranslate"><span class="pre">webrepl_cli.py</span></code> from the repository above.</p>
<p>See the MicroPython forum for other community-supported alternatives
to transfer files to an ESP32 board.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright - The MicroPython Documentation is Copyright © 2014-2024, Damien P. George, Paul Sokolovsky, and contributors.
      <span class="lastupdated">Last updated on 05 Mar 2024.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Language and External Links</span>
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Language</dt>
      <dd>
        <a href="https://openmv.io">English</a>
      </dd>
      <dd>
        <a href="http://doc.singtown.cc">中文</a>
      </dd>
    </dl>
    <hr/>
    <dl>
      <dt>External links</dt>
      <dd>
        <a href="https://openmv.io">openmv.io</a>
      </dd>
      <dd>
        <a href="http://forums.openmv.io">forums.openmv.io</a>
      </dd>
      <dd>
        <a href="https://github.com/openmv/openmv">github.com/openmv/openmv</a>
      </dd>
      <dd>
        <a href="http://micropython.org">micropython.org</a>
      </dd>
      <dd>
        <a href="http://forum.micropython.org">forum.micropython.org</a>
      </dd>
      <dd>
        <a href="https://github.com/micropython/micropython">github.com/micropython/micropython</a>
      </dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>